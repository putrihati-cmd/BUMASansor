{"file":"/Users/macm4/Documents/Projek/BUMASansor/backend/src/auth/auth.service.spec.ts","mappings":"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","names":[],"sources":["/Users/macm4/Documents/Projek/BUMASansor/backend/src/auth/auth.service.spec.ts"],"sourcesContent":["import { BadRequestException, UnauthorizedException } from '@nestjs/common';\nimport * as bcrypt from 'bcrypt';\nimport { Role } from '../common/enums/role.enum';\nimport { AuthService } from './auth.service';\n\njest.mock('bcrypt', () => ({\n  hash: jest.fn(async () => 'hashed'),\n  compare: jest.fn(async () => true),\n}));\n\ndescribe('AuthService', () => {\n  let service: AuthService;\n  let usersService: any;\n  let jwtService: any;\n  let prisma: any;\n  let config: any;\n\n  beforeEach(() => {\n    usersService = {\n      findByEmail: jest.fn(),\n      create: jest.fn(),\n      findById: jest.fn(),\n      findOrThrow: jest.fn(),\n    };\n\n    jwtService = {\n      signAsync: jest.fn(),\n      verifyAsync: jest.fn(),\n      decode: jest.fn(),\n    } as any;\n\n    prisma = {\n      refreshToken: {\n        findMany: jest.fn(),\n        update: jest.fn(),\n        updateMany: jest.fn(),\n        create: jest.fn(),\n      },\n    };\n\n    config = {\n      get: jest.fn((key: string, def: any) => def),\n    } as any;\n\n    service = new AuthService(usersService, jwtService, prisma, config);\n  });\n\n  describe('register', () => {\n    it('throws when email already exists', async () => {\n      usersService.findByEmail.mockResolvedValue({ id: 'u-1' });\n\n      await expect(\n        service.register({\n          email: 'a@b.com',\n          password: 'pass1234',\n          name: 'A',\n          role: Role.ADMIN,\n        } as any),\n      ).rejects.toBeInstanceOf(BadRequestException);\n    });\n\n    it('throws when WARUNG role missing warungId', async () => {\n      usersService.findByEmail.mockResolvedValue(null);\n\n      await expect(\n        service.register({\n          email: 'w@b.com',\n          password: 'pass1234',\n          name: 'W',\n          role: Role.WARUNG,\n        } as any),\n      ).rejects.toBeInstanceOf(BadRequestException);\n    });\n\n    it('hashes password and creates user on success', async () => {\n      usersService.findByEmail.mockResolvedValue(null);\n      usersService.create.mockResolvedValue({\n        id: 'u-1',\n        email: 'a@b.com',\n        name: 'A',\n        role: Role.ADMIN,\n        warungId: null,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      });\n\n      const result = await service.register({\n        email: 'a@b.com',\n        password: 'pass1234',\n        name: 'A',\n        role: Role.ADMIN,\n      } as any);\n\n      expect(bcrypt.hash as any as jest.Mock).toHaveBeenCalled();\n      expect(usersService.create).toHaveBeenCalled();\n      expect(result).toHaveProperty('id', 'u-1');\n      expect((result as any).password).toBeUndefined();\n    });\n  });\n\n  describe('login', () => {\n    it('throws when user not found', async () => {\n      usersService.findByEmail.mockResolvedValue(null);\n\n      await expect(\n        service.login({ email: 'x@x.com', password: 'x' } as any),\n      ).rejects.toBeInstanceOf(UnauthorizedException);\n    });\n\n    it('throws when password invalid', async () => {\n      (bcrypt.compare as any as jest.Mock).mockResolvedValue(false);\n      usersService.findByEmail.mockResolvedValue({\n        id: 'u-1',\n        email: 'x@x.com',\n        password: 'hash',\n        role: Role.ADMIN,\n      });\n\n      await expect(\n        service.login({ email: 'x@x.com', password: 'wrong' } as any),\n      ).rejects.toBeInstanceOf(UnauthorizedException);\n    });\n  });\n});\n"],"version":3}