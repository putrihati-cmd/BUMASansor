System Architecture & UX Flow Design for BUMAS Ansor Super App
Introduction
BUMAS Ansor aims to be a unified ecosystem for retail distribution, serving three distinct user personas: Super Admin (owner), Warung (merchant/POS/warehouse), and Kurir (logistics). The goal is to deliver a seamless experience akin to Shopeeâ€™s multi-service super app, where each user gets a tailored interface within a single application. Below I provide a comprehensive architecture covering app structure, database design, user flows, and a phased implementation roadmap.

1. App Structure: Single Super App vs. Separate Apps
The Dilemma
You need to decide whether to build three separate Flutter apps (Admin, POS, Driver) sharing a backend, or a single Flutter app that dynamically changes its UI based on the logged-in userâ€™s role.

Comparison
Aspect	Single Super App	Separate Apps
User Experience	Seamless: one download, one login, role-based UI. Users donâ€™t need to install multiple apps.	Fragmented: each role downloads its own app. Switching roles requires logging out and into another app.
Development Complexity	Higher: must handle role-based routing, feature toggles, and ensure UI components donâ€™t conflict.	Lower: each app is focused, simpler codebase, easier to test.
Code Reuse	High: shared authentication, API clients, models, utilities across all roles.	Moderate: can still share code via packages/modules, but each app is separate.
Deployment & Updates	Single app: users update once to get all role improvements.	Multiple apps: must update each app independently; users may miss updates.
Branding & Store Presence	One app on stores â€“ simpler for users to find.	Multiple apps could clutter store listings.
Role Switching	Easy: user logs in once, UI adapts. If a user has multiple roles (e.g., Warung also Kurir), they could switch within the app.	Impossible to have multiple roles without separate logins/accounts.
Performance	Slightly larger app size due to all features, but modern devices handle it well.	Smaller per-app size, but cumulative storage may be higher.
Security / Isolation	Need robust role-based access control (RBAC) on backend and frontend to prevent unauthorized views.	Natural isolation: each app only has code for its role.
Recommendation: Single Super App with Role-Based UI
For a small-to-medium business aiming to build a cohesive ecosystem, a single super app is the superior choice. It delivers the â€œall-in-oneâ€ feel, reduces friction for users, and simplifies branding. With a well-structured Flutter codebase and strict RBAC on the backend, you can achieve both flexibility and security.

How to Implement Role-Based UI in Flutter
Authentication & Role Fetching: After login, the backend returns user details including roles. Store this in a secure state (e.g., Riverpod/Bloc).

Role-Aware Router: Use a GoRouter or similar that redirects based on role. Define separate navigator stacks for each role.

Modular Feature Folders: Organize code by feature (e.g., features/auth, features/warung/pos, features/kurir/tasks). Each feature can be developed independently and conditionally loaded.

Dynamic Home Screen: After login, show a role-specific dashboard. For users with multiple roles (rare but possible), provide a role switcher in the app drawer.

Bottom Navigation: For Warung role, the bottom nav could include â€œPOSâ€, â€œInventoryâ€, â€œOrdersâ€. For Kurir, it would show â€œTasksâ€, â€œHistoryâ€, â€œProfileâ€. For Admin, â€œDashboardâ€, â€œUsersâ€, â€œReportsâ€.

Permissions: Use a PermissionService to check if the current user can access certain routes/features, and hide UI elements accordingly.

This approach keeps the codebase maintainable while delivering a tailored experience.

2. Database Design Refinement (Prisma Schema)
We need to model:

Users with roles.

Global products (BUMAS catalog) and local products (warung-specific).

Inventory per warung.

Transactions: sales to end customers and purchases from BUMAS.

Orders for restocking.

Delivery tasks for kurir.

Below is a proposed Prisma schema with explanations.

prisma
// User and Role Management
model User {
  id            String   @id @default(cuid())
  email         String   @unique
  passwordHash  String
  name          String
  phone         String?
  role          Role     @default(WARUNG) // WARUNG, KURIR, SUPER_ADMIN
  warungId      String?  // If role = WARUNG, link to a Warung
  kurirId       String?  // If role = KURIR, link to a Kurir
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  warung        Warung?  @relation(fields: [warungId], references: [id])
  kurir         Kurir?   @relation(fields: [kurirId], references: [id])
}

enum Role {
  SUPER_ADMIN
  WARUNG
  KURIR
}

// Warung (store) entity
model Warung {
  id            String   @id @default(cuid())
  name          String
  address       String
  phone         String
  latitude      Float?
  longitude     Float?
  ownerId       String   @unique // Reference to User.id
  owner         User     @relation(fields: [ownerId], references: [id])
  products      WarungProduct[]
  purchaseOrders Order[] // Orders placed by this warung
  createdAt     DateTime @default(now())
}

// Kurir entity
model Kurir {
  id            String   @id @default(cuid())
  userId        String   @unique
  user          User     @relation(fields: [userId], references: [id])
  vehiclePlate  String?
  isActive      Boolean  @default(true)
  deliveryTasks DeliveryTask[]
}

// Global product catalog (owned by BUMAS)
model GlobalProduct {
  id            String   @id @default(cuid())
  name          String
  description   String?
  sku           String   @unique
  barcode       String?  @unique
  category      String?
  unit          String   // e.g., "pcs", "kg"
  defaultPrice  Float?   // Suggested retail price
  imageUrl      String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  // Relationship to warung-specific products (if a warung chooses to stock this global product)
  warungProducts WarungProduct[]
}

// Local product per warung (inventory and pricing)
model WarungProduct {
  id              String   @id @default(cuid())
  warungId        String
  globalProductId String?  // Null if it's a custom product not in global catalog
  name            String   // Local name override
  sku             String?  // Local SKU
  barcode         String?  // Local barcode
  price           Float    // Selling price at this warung
  stock           Int      @default(0)
  minStock        Int?     // For reorder alerts
  imageUrl        String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  warung          Warung        @relation(fields: [warungId], references: [id])
  globalProduct   GlobalProduct? @relation(fields: [globalProductId], references: [id])
  saleLines       SaleLine[]
  purchaseOrderLines PurchaseOrderLine[]
}

// Transaction: represents a sale to end customer (POS) or a purchase from BUMAS
// We use a polymorphic approach with type field
model Transaction {
  id              String        @id @default(cuid())
  type            TransactionType // SALE or PURCHASE
  transactionNumber String       @unique // Human-readable number
  warungId        String?       // For SALE: the warung making the sale; for PURCHASE: the warung buying
  userId          String?       // User who performed the transaction
  customerName    String?       // For POS sales, optional
  totalAmount     Float
  paymentMethod   PaymentMethod? // CASH, QRIS, etc.
  paymentStatus   PaymentStatus @default(PAID) // For purchases, might be UNPAID
  createdAt       DateTime      @default(now())
  // Relations
  warung          Warung?       @relation(fields: [warungId], references: [id])
  user            User?         @relation(fields: [userId], references: [id])
  saleLines       SaleLine[]    // Only for type SALE
  purchaseLines   PurchaseOrderLine[] // Only for type PURCHASE (but purchase lines are linked via Order)
  // For purchases, we also have an Order entity that tracks the request
  order           Order?        // Optional link to the restocking order
}

enum TransactionType {
  SALE
  PURCHASE
}

enum PaymentMethod {
  CASH
  QRIS
  TRANSFER
}

enum PaymentStatus {
  PAID
  UNPAID
  PARTIAL
}

// Sale line items (for POS)
model SaleLine {
  id              String   @id @default(cuid())
  transactionId   String
  warungProductId String
  quantity        Int
  unitPrice       Float    // Price at time of sale
  subtotal        Float
  transaction     Transaction @relation(fields: [transactionId], references: [id])
  warungProduct   WarungProduct @relation(fields: [warungProductId], references: [id])
}

// Restocking Order (from Warung to BUMAS)
model Order {
  id              String   @id @default(cuid())
  orderNumber     String   @unique
  warungId        String
  status          OrderStatus @default(PENDING)
  totalAmount     Float
  notes           String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  // Relations
  warung          Warung   @relation(fields: [warungId], references: [id])
  lines           PurchaseOrderLine[]
  // When order is processed, a Transaction of type PURCHASE may be created
  transaction     Transaction? // Link to the purchase transaction after payment
  deliveryTask    DeliveryTask? // Optional link if order requires delivery
}

enum OrderStatus {
  PENDING
  CONFIRMED
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
}

// Purchase order line items (products ordered)
model PurchaseOrderLine {
  id              String   @id @default(cuid())
  orderId         String
  warungProductId String
  quantity        Int
  unitPrice       Float    // Price agreed at order time
  subtotal        Float
  order           Order    @relation(fields: [orderId], references: [id])
  warungProduct   WarungProduct @relation(fields: [warungProductId], references: [id])
}

// Delivery Task for Kurir
model DeliveryTask {
  id              String   @id @default(cuid())
  kurirId         String
  orderId         String   @unique // Each order becomes one delivery task
  status          DeliveryStatus @default(ASSIGNED)
  pickupLocation  String?  // BUMAS warehouse address
  dropoffLocation String   // Warung address
  scheduledDate   DateTime
  completedAt     DateTime?
  signatureUrl    String?  // Proof of delivery
  photoUrl        String?  // Photo evidence
  notes           String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  kurir           Kurir    @relation(fields: [kurirId], references: [id])
  order           Order    @relation(fields: [orderId], references: [id])
}

enum DeliveryStatus {
  ASSIGNED
  PICKED_UP
  IN_TRANSIT
  DELIVERED
  FAILED
}
Key Design Decisions
Global vs Local Products: GlobalProduct holds the master catalog. Each warung can link a local WarungProduct to a global one (via globalProductId) or create a completely custom product. Stock and price are managed per warung.

Transactions: A single Transaction table handles both sales and purchases, differentiated by type. This simplifies reporting and accounting. For purchases, the transaction is linked to an Order.

Order & Delivery: Restocking orders are separate from transactions to track the order lifecycle. When an order is ready, a purchase transaction is created (if payment is handled). Delivery tasks are assigned to kurir for each order.

User-Warung-Kurir Relationship: A User can have one warungId or kurirId based on role, enforcing a 1:1 relationship. Super admins have neither.

3. User Experience (UX) Flow
3.1 Warung User Journey
A Warung user (store owner/cashier) will use the app for two primary modes: Selling (POS) and Restocking (Ordering).

Login & Dashboard
After login, the user sees a Warung Dashboard with key metrics (todayâ€™s sales, low stock alerts, recent orders).

Bottom navigation: POS, Inventory, Orders, Reports, Profile.

Selling Mode (POS)
Open POS: Tap â€œPOSâ€ â€“ launches a cart screen with product catalog (local products with search/barcode scan).

Add Items: Scan barcode or search; product details (name, price) appear; adjust quantity.

Cart Review: See subtotal, apply discounts if any.

Checkout: Select payment method (Cash/QRIS). If QRIS, show QR code for customer to scan.

Payment Confirmation: Mark as paid; receipt generated (digital copy to customer via SMS/WhatsApp optional).

Transaction Record: Automatically updates inventory (reduces stock) and adds to daily sales report.

Restocking Mode (Order from BUMAS)
Navigate to â€œOrdersâ€ tab, then tap â€œNew Orderâ€ or â€œRestockâ€.

Browse Global Catalog: The app shows global products (BUMAS catalog) with suggested prices. User can also see their current stock for reference.

Add to Order Cart: Select products, quantities. The app may suggest reorder quantities based on minStock.

Review Order: See total, estimated delivery time.

Place Order: Submit order. Status becomes PENDING.

Order Tracking: User can view order status (Confirmed, Shipped, Delivered) in the Orders list. When delivered, inventory is automatically updated (stock increases).

Payment: If payment is required upfront, the order may trigger a purchase transaction (e.g., via transfer). The app can integrate with payment gateway.

Switching Between Modes
The user stays within the same app; the bottom navigation provides clear separation of concerns. The POS screen is optimized for speed (large buttons, barcode scanning), while the restocking flow is more like an e-commerce catalog.

3.2 Kurir User Journey
Kurirâ€™s interface is simple and focused on task execution.

Login & Dashboard
After login, Kurir sees a list of Todayâ€™s Delivery Tasks (assigned by admin/auto-assigned). Each task shows: order number, warung name, address, scheduled time.

Bottom navigation: Tasks, History, Profile.

Task Execution Flow
Select Task: Tap a task to view details: pickup location (BUMAS warehouse), dropoff location (warung), list of items.

Start Navigation: App opens maps (Google Maps/Apple Maps) with routing to pickup, then to dropoff.

Pickup Confirmation: Upon reaching warehouse, kurir taps â€œPicked Upâ€ to update status.

In Transit: Status changes to IN_TRANSIT; kurir can see ETA.

Delivery: At warung, kurir captures:

Digital Signature from recipient.

Photo of delivered goods.

Optionally collect COD payment (if applicable).

Mark Delivered: After capturing proof, task marked DELIVERED. The system updates order status and inventory.

Failure Handling: If delivery fails (warung closed), kurir can mark FAILED with notes, prompting admin intervention.

Simplicity
The Kurir app (within the super app) hides all unrelated features. The UI is optimized for field use: large buttons, offline capability (caching tasks, later sync), and GPS tracking.

3.3 Super Admin Journey
Super Admin has a comprehensive dashboard accessible via a separate section (e.g., hidden in drawer for admin users only). Features:

Analytics Dashboard: Sales overview, top products, warung performance, delivery success rates.

User Management: Create/edit users (Warung, Kurir), assign roles.

Product Catalog Management: Add/update global products.

Order Oversight: View all orders, intervene if needed (cancel, reassign).

System Settings: Configure thresholds, payment methods, etc.

4. Feature Roadmap (Phased Implementation)
Phase 1: MVP (Core Functionality) â€“ 2-3 months
User Authentication & Role-Based Access: Login with JWT, role assignment.

Super Admin:

Basic dashboard with summary stats.

User management (CRUD for Warung and Kurir).

Global product catalog management (add/edit products).

Warung:

POS: simple cart, cash payment, transaction recording.

Inventory: view and adjust stock manually.

Basic ordering: place restock order from global catalog (no payment integration, orders just recorded).

Reports: daily sales (simple list).

Kurir:

View assigned delivery tasks.

Update status (Picked Up, Delivered) manually.

No navigation integration; just manual address lookup.

Backend: All core APIs with Prisma, Redis for caching, Dockerized.

Phase 2: Enhanced Features â€“ 2-3 months
POS Enhancements:

Barcode scanning using device camera.

QRIS payment integration (static QR or dynamic).

Receipt printing (Bluetooth printer).

Inventory:

Stock alerts (low stock notifications).

Stock opname (cycle count) feature.

Ordering:

Payment integration for restock orders (e.g., Midtrans).

Order tracking with status updates.

Kurir:

In-app navigation with map integration.

Proof of delivery (photo, signature).

COD cash collection tracking.

Admin:

Detailed reports (sales per warung, product performance).

Order management (confirm, cancel).

Phase 3: Advanced & Ecosystem Growth â€“ 3-4 months
Analytics & Business Intelligence:

Advanced dashboards with charts.

Predictive stock suggestions.

Loyalty Programs:

Customer loyalty for warung end-customers.

Warung rewards based on purchase volume.

Multi-Warehouse Support:

If BUMAS expands to multiple warehouses, support inventory across locations.

Offline Capability:

For kurir and POS in areas with poor connectivity (local storage, sync when online).

Role Switcher:

For users with multiple roles (e.g., Warung also acts as Kurir), allow switching within app.

Integration with Accounting Software:

Export transactions to popular accounting tools.

Conclusion
Building BUMAS Ansor as a single Flutter super app with role-based UI is the optimal path to deliver a cohesive experience while keeping development manageable. The database design separates global and local concerns, enabling warungs to operate independently while staying connected to the central ecosystem. The UX flows are tailored to each roleâ€™s daily tasks, ensuring efficiency. By following a phased roadmap, you can launch an MVP quickly and iterate based on user feedback, gradually adding sophistication.

This architecture provides a solid foundation for a scalable retail distribution ecosystem, ready to grow with your business.


----

BUMAS Ansor: Comprehensive System Architecture & UX Flow Design
Executive Summary
Based on your vision and current tech stack, I recommend a hybrid approach: One Super App with role-based UI switching + optional lightweight companion apps for specialized roles. This gives you the best of both worldsâ€”centralized maintenance with role-optimized experiences.

1. App Structure Decision: Single Super App vs Multiple Apps
Recommended Approach: Single Super App with Dynamic Role-Based UI
Rationale for Small-to-Medium Business:
Pros:

Single Codebase: One Flutter project = faster development, easier maintenance, consistent UI/UX patterns
Unified Updates: Push updates once, all users get improvements simultaneously
Cross-Role Flexibility: Users who wear multiple hats (e.g., Warung owner who also does deliveries) don't need multiple apps
Shared Infrastructure: Common components (auth, notifications, API client, state management)
Lower Development Cost: ~60% less development time compared to maintaining 3 separate apps
Easier Onboarding: One app download, roles assigned server-side

Cons:

Larger App Size: ~15-25MB (mitigated by lazy loading and code splitting)
Slight Complexity: Role-switching logic requires careful state management
Permission Management: Need robust RBAC implementation

Alternative Lightweight Apps (Optional Phase 2):

Kurir Lite App: Stripped-down 5MB app for drivers with older phones
POS Kiosk Mode: Dedicated tablet build with locked-down UI


2. Database Design Refinement (Prisma Schema)
Core Schema Architecture
prisma// ============================================
// USER & ROLE MANAGEMENT
// ============================================

model User {
  id            String   @id @default(cuid())
  email         String   @unique
  phone         String?  @unique
  passwordHash  String
  fullName      String
  avatar        String?
  
  role          UserRole @default(WARUNG)
  status        UserStatus @default(ACTIVE)
  
  // Relationships
  warung        Warung?
  kurirProfile  KurirProfile?
  createdOrders Order[]  @relation("OrderCreatedBy")
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([email])
  @@index([phone])
}

enum UserRole {
  SUPER_ADMIN
  WARUNG
  KURIR
}

enum UserStatus {
  ACTIVE
  SUSPENDED
  INACTIVE
}

// ============================================
// WARUNG (MERCHANT/POS/WAREHOUSE)
// ============================================

model Warung {
  id            String   @id @default(cuid())
  userId        String   @unique
  user          User     @relation(fields: [userId], references: [id])
  
  // Business Info
  businessName  String
  address       String
  latitude      Float?
  longitude     Float?
  phone         String
  
  // Business Settings
  isActive      Boolean  @default(true)
  canSelfOrder  Boolean  @default(true) // Can order from BUMAS
  creditLimit   Decimal  @default(0) @db.Decimal(12, 2)
  
  // Relationships
  inventory     WarungInventory[]
  sales         Sale[]
  restockOrders RestockOrder[]
  deliveries    Delivery[]
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([userId])
}

// ============================================
// PRODUCT CATALOG (TWO-TIER SYSTEM)
// ============================================

// Global BUMAS Product Catalog
model GlobalProduct {
  id            String   @id @default(cuid())
  sku           String   @unique
  barcode       String?  @unique
  name          String
  description   String?
  category      String
  
  // Pricing (BUMAS wholesale to Warung)
  basePrice     Decimal  @db.Decimal(10, 2) // Warung purchase price
  suggestedRetail Decimal @db.Decimal(10, 2) // Suggested selling price
  
  // Media
  imageUrl      String?
  
  // Master Stock (BUMAS Central Warehouse)
  centralStock  Int      @default(0)
  minStockLevel Int      @default(10)
  
  // Relationships
  warungInventories WarungInventory[]
  restockOrderItems RestockOrderItem[]
  
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([sku])
  @@index([barcode])
  @@index([category])
}

// Local Warung Inventory (Instance of Global Product at specific Warung)
model WarungInventory {
  id            String   @id @default(cuid())
  
  warungId      String
  warung        Warung   @relation(fields: [warungId], references: [id])
  
  globalProductId String?
  globalProduct GlobalProduct? @relation(fields: [globalProductId], references: [id])
  
  // Custom Product Support (for Warung's own products)
  isCustomProduct Boolean @default(false)
  customSku     String?
  customBarcode String?
  customName    String?
  
  // Warung-specific Pricing
  purchasePrice Decimal  @db.Decimal(10, 2) // What Warung paid
  sellingPrice  Decimal  @db.Decimal(10, 2) // What Warung sells for
  
  // Stock Management
  currentStock  Int      @default(0)
  minStockAlert Int      @default(5)
  
  // Tracking
  lastRestockedAt DateTime?
  
  // Relationships
  saleItems     SaleItem[]
  stockAdjustments StockAdjustment[]
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@unique([warungId, globalProductId])
  @@unique([warungId, customSku])
  @@index([warungId])
  @@index([globalProductId])
}

// ============================================
// SALES (POS TRANSACTIONS)
// ============================================

model Sale {
  id            String   @id @default(cuid())
  saleNumber    String   @unique // SALE-20260216-001
  
  warungId      String
  warung        Warung   @relation(fields: [warungId], references: [id])
  
  // Transaction Details
  subtotal      Decimal  @db.Decimal(10, 2)
  tax           Decimal  @default(0) @db.Decimal(10, 2)
  discount      Decimal  @default(0) @db.Decimal(10, 2)
  total         Decimal  @db.Decimal(10, 2)
  
  // Payment
  paymentMethod PaymentMethod
  paymentStatus PaymentStatus @default(COMPLETED)
  paidAmount    Decimal  @db.Decimal(10, 2)
  changeAmount  Decimal  @default(0) @db.Decimal(10, 2)
  
  // Customer Info (Optional)
  customerName  String?
  customerPhone String?
  
  // Relationships
  items         SaleItem[]
  
  createdAt     DateTime @default(now())
  
  @@index([warungId])
  @@index([saleNumber])
  @@index([createdAt])
}

model SaleItem {
  id            String   @id @default(cuid())
  
  saleId        String
  sale          Sale     @relation(fields: [saleId], references: [id], onDelete: Cascade)
  
  inventoryId   String
  inventory     WarungInventory @relation(fields: [inventoryId], references: [id])
  
  // Snapshot at time of sale
  productName   String
  quantity      Int
  unitPrice     Decimal  @db.Decimal(10, 2)
  subtotal      Decimal  @db.Decimal(10, 2)
  
  @@index([saleId])
  @@index([inventoryId])
}

enum PaymentMethod {
  CASH
  QRIS
  TRANSFER
  EDC
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
}

// ============================================
// RESTOCKING (B2B: Warung orders from BUMAS)
// ============================================

model RestockOrder {
  id            String   @id @default(cuid())
  orderNumber   String   @unique // RESTOCK-20260216-001
  
  warungId      String
  warung        Warung   @relation(fields: [warungId], references: [id])
  
  // Order Details
  status        RestockStatus @default(PENDING)
  totalAmount   Decimal  @db.Decimal(12, 2)
  
  // Fulfillment
  assignedKurirId String?
  delivery      Delivery?
  
  notes         String?
  
  items         RestockOrderItem[]
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([warungId])
  @@index([orderNumber])
  @@index([status])
}

model RestockOrderItem {
  id            String   @id @default(cuid())
  
  restockOrderId String
  restockOrder  RestockOrder @relation(fields: [restockOrderId], references: [id], onDelete: Cascade)
  
  globalProductId String
  globalProduct GlobalProduct @relation(fields: [globalProductId], references: [id])
  
  quantity      Int
  unitPrice     Decimal  @db.Decimal(10, 2)
  subtotal      Decimal  @db.Decimal(10, 2)
  
  @@index([restockOrderId])
  @@index([globalProductId])
}

enum RestockStatus {
  PENDING         // Warung submitted order
  APPROVED        // Admin approved
  PREPARING       // BUMAS warehouse packing
  IN_TRANSIT      // Kurir picked up
  DELIVERED       // Completed
  CANCELLED
}

// ============================================
// LOGISTICS (KURIR DELIVERIES)
// ============================================

model KurirProfile {
  id            String   @id @default(cuid())
  userId        String   @unique
  user          User     @relation(fields: [userId], references: [id])
  
  vehicleType   VehicleType
  vehiclePlate  String
  
  isAvailable   Boolean  @default(true)
  
  deliveries    Delivery[]
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([userId])
}

enum VehicleType {
  MOTORCYCLE
  CAR
  TRUCK
}

model Delivery {
  id            String   @id @default(cuid())
  deliveryNumber String  @unique // DEL-20260216-001
  
  restockOrderId String  @unique
  restockOrder  RestockOrder @relation(fields: [restockOrderId], references: [id])
  
  kurirId       String
  kurir         KurirProfile @relation(fields: [kurirId], references: [id])
  
  // Delivery Details
  status        DeliveryStatus @default(ASSIGNED)
  
  pickupAddress String   // BUMAS Warehouse
  pickupLat     Float?
  pickupLng     Float?
  
  deliveryAddress String // Warung address
  deliveryLat   Float?
  deliveryLng   Float?
  
  // Timestamps
  assignedAt    DateTime @default(now())
  pickedUpAt    DateTime?
  deliveredAt   DateTime?
  
  // Proof of Delivery
  recipientName String?
  signature     String?  // Base64 or URL
  photoProof    String?  // URL
  
  // COD Handling
  codAmount     Decimal? @db.Decimal(10, 2)
  codCollected  Boolean  @default(false)
  
  notes         String?
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([kurirId])
  @@index([status])
  @@index([deliveryNumber])
}

enum DeliveryStatus {
  ASSIGNED        // Kurir assigned
  PICKED_UP       // Kurir collected from warehouse
  IN_TRANSIT      // On the way
  DELIVERED       // Successfully delivered
  FAILED          // Delivery failed
  CANCELLED
}

// ============================================
// STOCK ADJUSTMENTS (OPNAME)
// ============================================

model StockAdjustment {
  id            String   @id @default(cuid())
  
  inventoryId   String
  inventory     WarungInventory @relation(fields: [inventoryId], references: [id])
  
  type          AdjustmentType
  quantityChange Int       // Positive or negative
  previousStock Int
  newStock      Int
  
  reason        String?
  notes         String?
  
  createdBy     String    // User ID
  createdAt     DateTime  @default(now())
  
  @@index([inventoryId])
  @@index([createdAt])
}

enum AdjustmentType {
  MANUAL_COUNT    // Stock opname
  DAMAGED
  EXPIRED
  LOST
  FOUND
  RETURN
}
```

### Key Design Decisions Explained

**1. Global vs Local Products:**
- `GlobalProduct`: BUMAS master catalog (wholesale products)
- `WarungInventory`: Warung's actual stock (can link to GlobalProduct OR be custom)
- This allows Warungs to sell both BUMAS products AND their own items (e.g., local snacks)

**2. Dual Transaction Types:**
- `Sale`: Warung selling to end customers (POS)
- `RestockOrder`: Warung buying from BUMAS (B2B)
- Clearly separated for accounting and reporting

**3. Price Tracking:**
- `GlobalProduct.basePrice`: What Warung pays BUMAS
- `WarungInventory.sellingPrice`: What end customer pays
- Enables profit margin calculation per Warung

---

## 3. User Experience (UX) Flow Design

### A. Warung User Journey: Role Switching Architecture

#### **Home Dashboard (Mode Selector)**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸª BUMAS Ansor - Warung Jaya      â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                     â”‚
â”‚  ğŸ“Š Today's Summary                 â”‚
â”‚  Sales: Rp 2,450,000                â”‚
â”‚  Transactions: 48                   â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                     â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“ â”‚
â”‚  â”ƒ ğŸ’° SELLING  â”ƒ  â”ƒ ğŸ“¦ RESTOCK  â”ƒ â”‚
â”‚  â”ƒ    MODE     â”ƒ  â”ƒ    MODE     â”ƒ â”‚
â”‚  â”ƒ             â”ƒ  â”ƒ             â”ƒ â”‚
â”‚  â”ƒ Operate POS â”ƒ  â”ƒ Order Stock â”ƒ â”‚
â”‚  â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”›  â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”› â”‚
â”‚                                     â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“ â”‚
â”‚  â”ƒ ğŸ“Š REPORTS  â”ƒ  â”ƒ âš™ï¸ INVENTORYâ”ƒ â”‚
â”‚  â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”›  â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”› â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### **SELLING MODE (POS Interface)**

**Flow: Customer Purchase**

1. **Scan/Search Product**
```
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ ğŸ” [Scan Barcode]  [Search...]  â”‚
   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚ ğŸ›’ CART (3 items)               â”‚
   â”‚                                 â”‚
   â”‚ Indomie Goreng  x2   Rp 6,000  â”‚
   â”‚ Aqua 600ml      x5   Rp 12,500 â”‚
   â”‚ Gudang Garam    x1   Rp 18,000 â”‚
   â”‚                                 â”‚
   â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
   â”‚ TOTAL:           Rp 36,500      â”‚
   â”‚                                 â”‚
   â”‚ [ğŸ’µ CASH]  [ğŸ“± QRIS]            â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

2. **Payment Processing**
   - Cash: Input amount â†’ Calculate change â†’ Print receipt
   - QRIS: Show QR â†’ Wait for payment confirmation

3. **Auto Stock Deduction** (Backend handles inventory update)

#### **RESTOCKING MODE (B2B Ordering)**

**Flow: Order from BUMAS**

1. **Browse BUMAS Catalog**
```
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ ğŸ“¦ Order from BUMAS Warehouse   â”‚
   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚ ğŸ” Search products...            â”‚
   â”‚                                 â”‚
   â”‚ ğŸ“¦ Indomie Goreng               â”‚
   â”‚    Stock: 5 left  âš ï¸ Low        â”‚
   â”‚    Rp 2,500/pcs                 â”‚
   â”‚    [+ Add to Order]             â”‚
   â”‚                                 â”‚
   â”‚ ğŸ“¦ Aqua 600ml                   â”‚
   â”‚    Stock: 48 left  âœ…           â”‚
   â”‚    Rp 2,200/pcs                 â”‚
   â”‚    [+ Add to Order]             â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

2. **Review & Submit Order**
```
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ ğŸ“‹ Restock Order #R-001         â”‚
   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚ Indomie Goreng  x100  Rp 250K  â”‚
   â”‚ Aqua 600ml      x50   Rp 110K  â”‚
   â”‚                                 â”‚
   â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
   â”‚ Total: Rp 360,000               â”‚
   â”‚                                 â”‚
   â”‚ Delivery: Tomorrow 10:00 AM     â”‚
   â”‚                                 â”‚
   â”‚ [Cancel]  [ğŸš€ Submit Order]     â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

3. **Track Delivery Status**
   - Real-time updates from Kurir
   - Notification when out for delivery

#### **INVENTORY MANAGEMENT**

**Stock Opname Flow:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ“¦ Inventory - Warung Jaya      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ” Filter: [All] [Low Stock]    â”‚
â”‚                                 â”‚
â”‚ Indomie Goreng                  â”‚
â”‚ System: 5  â†’  Actual: [7]       â”‚
â”‚ [Adjust +2]                     â”‚
â”‚                                 â”‚
â”‚ Aqua 600ml                      â”‚
â”‚ System: 48  â†’  Actual: [45]     â”‚
â”‚ Reason: [3 damaged]             â”‚
â”‚ [Adjust -3]                     â”‚
â”‚                                 â”‚
â”‚ [Save Adjustments]              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### B. Kurir User Journey: Simplified Logistics

#### **Daily Task Dashboard**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸšš Kurir - Budi Santoso         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ“ Active Status: [ğŸŸ¢ Available]â”‚
â”‚                                 â”‚
â”‚ ğŸ“¦ TODAY'S DELIVERIES (3)       â”‚
â”‚                                 â”‚
â”‚ â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“ â”‚
â”‚ â”ƒ #DEL-001  ğŸŸ¡ ASSIGNED       â”ƒ â”‚
â”‚ â”ƒ Warung Jaya                 â”ƒ â”‚
â”‚ â”ƒ Jl. Sudirman 123            â”ƒ â”‚
â”‚ â”ƒ 15 items  |  3.2 km         â”ƒ â”‚
â”‚ â”ƒ [View Details]  [Start]     â”ƒ â”‚
â”‚ â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”› â”‚
â”‚                                 â”‚
â”‚ â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“ â”‚
â”‚ â”ƒ #DEL-002  âœ… DELIVERED      â”ƒ â”‚
â”‚ â”ƒ Warung Sejahtera            â”ƒ â”‚
â”‚ â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”› â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### **Delivery Execution Flow**

**Step 1: Pickup from BUMAS Warehouse**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ“¦ Pickup - Order #R-12345      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ“ BUMAS Central Warehouse      â”‚
â”‚    Jl. Gatot Subroto 45         â”‚
â”‚                                 â”‚
â”‚ Items to Pick (15):             â”‚
â”‚ â˜ Indomie Goreng  x100          â”‚
â”‚ â˜ Aqua 600ml      x50           â”‚
â”‚ â˜ Gudang Garam    x20           â”‚
â”‚ ...                             â”‚
â”‚                                 â”‚
â”‚ [âœ“ Confirm Pickup]              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Step 2: Navigate to Destination**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ—ºï¸  EN ROUTE TO WARUNG JAYA     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [     EMBEDDED MAP VIEW     ]  â”‚
â”‚ [     Google Maps API       ]  â”‚
â”‚ [     Real-time Navigation  ]  â”‚
â”‚                                 â”‚
â”‚ ğŸ“ Distance: 1.8 km             â”‚
â”‚ â±ï¸  ETA: 12 minutes             â”‚
â”‚                                 â”‚
â”‚ â˜ï¸  [Call Warung]               â”‚
â”‚ ğŸ“ [Get Directions]             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Step 3: Proof of Delivery**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âœ… Complete Delivery            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Warung Jaya                     â”‚
â”‚ Jl. Sudirman 123                â”‚
â”‚                                 â”‚
â”‚ ğŸ“¸ Take Photo Proof:            â”‚
â”‚ [  Camera Viewfinder  ]        â”‚
â”‚                                 â”‚
â”‚ âœï¸ Recipient Signature:         â”‚
â”‚ [  Signature Pad      ]        â”‚
â”‚                                 â”‚
â”‚ ğŸ‘¤ Received by: [Input Name]    â”‚
â”‚                                 â”‚
â”‚ ğŸ’° COD Collection (if any):     â”‚
â”‚    Rp [          ]              â”‚
â”‚                                 â”‚
â”‚ [Complete Delivery]             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### C. Super Admin Dashboard (God Mode)
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ‘‘ BUMAS ANSOR - SUPER ADMIN         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ“Š REAL-TIME OVERVIEW                â”‚
â”‚                                      â”‚
â”‚ ğŸ’° Today's Revenue:  Rp 45,230,000  â”‚
â”‚ ğŸª Active Warungs:   48 / 52        â”‚
â”‚ ğŸšš Active Deliveries: 12             â”‚
â”‚ âš ï¸  Low Stock Alerts:  3             â”‚
â”‚                                      â”‚
â”‚ â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”  â”‚
â”‚                                      â”‚
â”‚ [ğŸ“¦ Global Catalog]  [ğŸª Warungs]   â”‚
â”‚ [ğŸšš Logistics]       [ğŸ‘¥ Users]     â”‚
â”‚ [ğŸ’¹ Financial Reports]               â”‚
â”‚ [âš™ï¸  System Settings]                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Key Admin Features:**
- Override any order/delivery status
- Manually adjust central stock
- View consolidated P&L across all Warungs
- Manage user permissions and credits

---

## 4. Implementation Strategy: Role-Based UI Switching

### Flutter Architecture Pattern

**Directory Structure:**
```
lib/
â”œâ”€â”€ main.dart
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”œâ”€â”€ auth_provider.dart (Role detection)
â”‚   â”‚   â””â”€â”€ role_guard.dart
â”‚   â”œâ”€â”€ constants/
â”‚   â””â”€â”€ utils/
â”œâ”€â”€ features/
â”‚   â”œâ”€â”€ admin/
â”‚   â”‚   â”œâ”€â”€ screens/
â”‚   â”‚   â”‚   â”œâ”€â”€ admin_dashboard.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ global_catalog_screen.dart
â”‚   â”‚   â”‚   â””â”€â”€ user_management_screen.dart
â”‚   â”‚   â””â”€â”€ widgets/
â”‚   â”œâ”€â”€ warung/
â”‚   â”‚   â”œâ”€â”€ screens/
â”‚   â”‚   â”‚   â”œâ”€â”€ warung_home.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ pos_screen.dart (Selling Mode)
â”‚   â”‚   â”‚   â”œâ”€â”€ restock_screen.dart (Ordering Mode)
â”‚   â”‚   â”‚   â””â”€â”€ inventory_screen.dart
â”‚   â”‚   â””â”€â”€ widgets/
â”‚   â””â”€â”€ kurir/
â”‚       â”œâ”€â”€ screens/
â”‚       â”‚   â”œâ”€â”€ kurir_dashboard.dart
â”‚       â”‚   â”œâ”€â”€ delivery_detail_screen.dart
â”‚       â”‚   â””â”€â”€ pod_screen.dart (Proof of Delivery)
â”‚       â””â”€â”€ widgets/
â”œâ”€â”€ shared/
â”‚   â”œâ”€â”€ widgets/ (Reusable components)
â”‚   â”œâ”€â”€ models/
â”‚   â””â”€â”€ services/
â””â”€â”€ router/
    â””â”€â”€ app_router.dart (Role-based routing)
Code Implementation Example
1. Role-Based Routing (app_router.dart):
dartimport 'package:flutter/material.dart';
import 'package:provider/provider.dart';

class AppRouter {
  static Route<dynamic> generateRoute(RouteSettings settings) {
    return MaterialPageRoute(builder: (context) {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final userRole = authProvider.currentUser?.role;

      // Default route based on role
      if (settings.name == '/') {
        switch (userRole) {
          case UserRole.SUPER_ADMIN:
            return AdminDashboard();
          case UserRole.WARUNG:
            return WarungHome();
          case UserRole.KURIR:
            return KurirDashboard();
          default:
            return LoginScreen();
        }
      }

      // Named routes with role guards
      switch (settings.name) {
        case '/pos':
          return _roleGuard(userRole, UserRole.WARUNG, POSScreen());
        case '/restock':
          return _roleGuard(userRole, UserRole.WARUNG, RestockScreen());
        case '/delivery':
          return _roleGuard(userRole, UserRole.KURIR, DeliveryDetailScreen());
        case '/admin/catalog':
          return _roleGuard(userRole, UserRole.SUPER_ADMIN, GlobalCatalogScreen());
        default:
          return UnauthorizedScreen();
      }
    });
  }

  static Widget _roleGuard(UserRole? currentRole, UserRole requiredRole, Widget screen) {
    if (currentRole == requiredRole || currentRole == UserRole.SUPER_ADMIN) {
      return screen;
    }
    return UnauthorizedScreen();
  }
}
2. Warung Home with Mode Switching (warung_home.dart):
dartclass WarungHome extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('BUMAS Ansor - Warung'),
        actions: [
          IconButton(
            icon: Icon(Icons.notifications),
            onPressed: () => _showNotifications(context),
          ),
        ],
      ),
      body: Padding(
        padding: EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Today's Summary Card
            _buildSummaryCard(),
            SizedBox(height: 24),
            
            // Mode Selector Grid
            Text('Select Mode', style: Theme.of(context).textTheme.headline6),
            SizedBox(height: 16),
            GridView.count(
              shrinkWrap: true,
              crossAxisCount: 2,
              crossAxisSpacing: 16,
              mainAxisSpacing: 16,
              children: [
                _buildModeCard(
                  context,
                  icon: Icons.point_of_sale,
                  title: 'SELLING MODE',
                  subtitle: 'Operate POS',
                  color: Colors.green,
                  onTap: () => Navigator.pushNamed(context, '/pos'),
                ),
                _buildModeCard(
                  context,
                  icon: Icons.inventory_2,
                  title: 'RESTOCK MODE',
                  subtitle: 'Order Stock',
                  color: Colors.blue,
                  onTap: () => Navigator.pushNamed(context, '/restock'),
                ),
                _buildModeCard(
                  context,
                  icon: Icons.analytics,
                  title: 'REPORTS',
                  subtitle: 'View Sales',
                  color: Colors.orange,
                  onTap: () => Navigator.pushNamed(context, '/reports'),
                ),
                _buildModeCard(
                  context,
                  icon: Icons.warehouse,
                  title: 'INVENTORY',
                  subtitle: 'Manage Stock',
                  color: Colors.purple,
                  onTap: () => Navigator.pushNamed(context, '/inventory'),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildModeCard(BuildContext context, {
    required IconData icon,
    required String title,
    required String subtitle,
    required Color color,
    required VoidCallback onTap,
  }) {
    return Card(
      elevation: 4,
      child: InkWell(
        onTap: onTap,
        child: Padding(
          padding: EdgeInsets.all(16),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(icon, size: 48, color: color),
              SizedBox(height: 8),
              Text(
                title,
                style: TextStyle(fontWeight: FontWeight.bold),
                textAlign: TextAlign.center,
              ),
              Text(
                subtitle,
                style: TextStyle(fontSize: 12, color: Colors.grey[600]),
                textAlign: TextAlign.center,
              ),
            ],
          ),
        ),
      ),
    );
  }
}
3. Backend API Role Validation (NestJS):
typescript// src/auth/decorators/roles.decorator.ts
import { SetMetadata } from '@nestjs/common';
import { UserRole } from '@prisma/client';

export const ROLES_KEY = 'roles';
export const Roles = (...roles: UserRole[]) => SetMetadata(ROLES_KEY, roles);

// src/auth/guards/roles.guard.ts
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<UserRole[]>(ROLES_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);
    
    if (!requiredRoles) {
      return true;
    }
    
    const { user } = context.switchToHttp().getRequest();
    
    // Super Admin bypasses all role checks
    if (user.role === UserRole.SUPER_ADMIN) {
      return true;
    }
    
    return requiredRoles.some((role) => user.role === role);
  }
}

// Usage in controllers:
@Controller('sales')
export class SalesController {
  @Post()
  @Roles(UserRole.WARUNG)
  @UseGuards(JwtAuthGuard, RolesGuard)
  async createSale(@Body() dto: CreateSaleDto, @CurrentUser() user: User) {
    return this.salesService.createSale(dto, user.warung.id);
  }
}

5. Feature Roadmap: Phased Implementation
Phase 1: MVP (Month 1-2) - Core POS & Basic Logistics
Goal: Get basic sales and inventory working for 5-10 pilot Warungs
Features:

âœ… User authentication with role-based login
âœ… POS System (Warung):

Barcode scanning
Manual product search
Cart management
Cash payment only
Receipt generation (digital)


âœ… Basic Inventory:

View stock levels
Manual stock adjustment
Low stock alerts


âœ… Global Product Catalog (Admin):

CRUD operations for products
Price management


âœ… Simple Reporting:

Daily sales summary for Warung
Total revenue for Admin



Backend APIs:

POST /auth/login
GET /products (filtered by Warung inventory)
POST /sales (create transaction)
PATCH /inventory/:id/adjust (stock opname)
GET /reports/daily-sales

Deployment:

Single Flutter app (role switching implemented but only WARUNG and SUPER_ADMIN active)
Backend on VPS with Docker
PostgreSQL + Redis


Phase 2: B2B Ordering & Delivery Management (Month 3-4)
Goal: Enable Warungs to order from BUMAS and track deliveries
Features:

âœ… Restocking System (Warung):

Browse BUMAS catalog with pricing
Add items to restock order
Submit order for approval
Track order status


âœ… Order Management (Admin):

Approve/reject restock orders
Assign Kurir to deliveries
Mark orders as "Preparing"


âœ… Kurir Module:

Daily task list
Pickup confirmation
Basic navigation (external Google Maps link)
Proof of delivery (photo + signature)


âœ… Notifications:

Push notifications for order status changes
Low stock alerts for Warung



Backend APIs:

POST /restock-orders (Warung creates order)
PATCH /restock-orders/:id/approve (Admin)
POST /deliveries (Admin assigns Kurir)
PATCH /deliveries/:id/status (Kurir updates)
POST /deliveries/:id/pod (Proof of Delivery)

New Tech:

Firebase Cloud Messaging (FCM) for push notifications
Google Maps API integration


Phase 3: Advanced Features & Analytics (Month 5-6)
Goal: Optimize operations and provide business insights
Features:

âœ… Payment Methods:

QRIS integration (Midtrans/Xendit)
Bank transfer reconciliation


âœ… Advanced Inventory:

Batch/expiry tracking
Automated reorder suggestions (based on sales velocity)
Product bundling


âœ… Analytics Dashboard:

Sales trends (daily/weekly/monthly)
Best-selling products
Profit margin analysis
Warung performance comparison (Admin)


âœ… Customer Management:

Loyalty points system
Customer purchase history


âœ… Route Optimization (Kurir):

Multi-stop delivery planning
Embedded map in app (not just external link)



Backend APIs:

POST /payments/qris/generate
GET /analytics/sales-trends
GET /analytics/top-products
POST /inventory/reorder-suggestions


Phase 4: Scalability & Automation (Month 7+)
Goal: Handle 100+ Warungs and reduce manual processes
Features:

âœ… Warehouse Management System (Admin):

Bin location tracking
Picking/packing optimization
Barcode-based fulfillment


âœ… Credit System:

Credit limits for Warungs
Installment payments
Auto-suspend for overdue accounts


âœ… Multi-warehouse Support:

Regional distribution centers
Stock transfer between warehouses


âœ… API for Third-party Integrations:

Accounting software (e.g., Accurate Online)
ERP systems
Payment gateways


âœ… Offline Mode:

Local database sync (Hive/SQLite)
Queue transactions when offline
Auto-sync when online



Architecture Evolution:

Migrate to Microservices (NestJS modules â†’ separate services)
Message queue (RabbitMQ/Redis Pub/Sub) for async tasks
CDN for product images
Elasticsearch for advanced search


6. Technical Considerations & Best Practices
A. State Management (Flutter)
Recommended: Provider + Riverpod (for complex state) or Bloc (if team prefers event-driven)
Example Structure:
dart// providers/auth_provider.dart
class AuthProvider with ChangeNotifier {
  User? _currentUser;
  
  User? get currentUser => _currentUser;
  UserRole? get userRole => _currentUser?.role;
  
  Future<void> login(String email, String password) async {
    final response = await apiService.login(email, password);
    _currentUser = response.user;
    notifyListeners();
  }
  
  bool hasRole(UserRole role) {
    return _currentUser?.role == role || _currentUser?.role == UserRole.SUPER_ADMIN;
  }
}

// providers/cart_provider.dart (for POS)
class CartProvider with ChangeNotifier {
  List<CartItem> _items = [];
  
  void addItem(Product product, int quantity) {
    // Logic
    notifyListeners();
  }
  
  Decimal get totalAmount => _items.fold(
    Decimal.zero,
    (sum, item) => sum + (item.price * Decimal.fromInt(item.quantity)),
  );
}
B. Offline-First Considerations
Phase 1-2: Online-only (simpler)
Phase 4: Add offline support for POS transactions
Strategy:

Use Hive or SQLite for local storage
Queue failed API calls in local DB
Retry with exponential backoff when connection restored
Show sync status indicator in UI

C. Security Best Practices
Backend:

JWT tokens with short expiration (15 min access, 7 day refresh)
Role-based guards on ALL endpoints
Input validation with class-validator
Rate limiting (e.g., 100 requests/min per user)
HTTPS only

Frontend:

Store tokens in flutter_secure_storage
Auto-logout on token expiry
Encrypt sensitive local data
Obfuscate code in production build

D. Performance Optimization
Flutter:

Lazy load product images with cached_network_image
Paginate product lists (20-50 items per page)
Use ListView.builder for long lists
Debounce search inputs (300ms delay)

Backend:

Database indexing on foreign keys and frequently queried fields (already in schema)
Redis caching for:

Global product catalog (cache for 1 hour)
Daily sales summaries (cache for 5 minutes)


Connection pooling for PostgreSQL
Compress API responses (gzip)


7. Deployment Strategy
Development Environment
yaml# docker-compose.yml
version: '3.8'
services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: bumas_dev
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  backend:
    build: ./backend
    ports:
      - "3000:3000"
    environment:
      DATABASE_URL: postgresql://postgres:postgres@postgres:5432/bumas_dev
      REDIS_URL: redis://redis:6379
    depends_on:
      - postgres
      - redis
    volumes:
      - ./backend:/app
    command: npm run start:dev

volumes:
  postgres_data:
Production Deployment
Backend:

VPS (DigitalOcean/AWS EC2): 4GB RAM, 2 vCPU (for 50 Warungs)
Docker Swarm or Kubernetes (for 100+ Warungs)
Database: Managed PostgreSQL (Supabase/AWS RDS)
Redis: Managed Redis (Upstash/AWS ElastiCache)
File Storage: AWS S3 / Cloudflare R2 (for product images, receipts)

Frontend:

Build separate APKs for different roles (optional optimization):

bash  flutter build apk --dart-define=BUILD_FLAVOR=warung
  flutter build apk --dart-define=BUILD_FLAVOR=kurir

Distribute via Google Play Store (internal testing â†’ beta â†’ production)
Or use CodePush equivalent for Flutter (Shorebird) for instant updates

CI/CD Pipeline
yaml# .github/workflows/deploy.yml
name: Deploy Backend
on:
  push:
    branches: [main]
    
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Build Docker image
        run: docker build -t bumas-backend:latest ./backend
      - name: Push to registry
        run: docker push your-registry/bumas-backend:latest
      - name: Deploy to VPS
        run: ssh user@your-vps 'docker pull && docker-compose up -d'

8. Cost Estimation (Monthly, for 50 Warungs)
ItemCost (USD)VPS (4GB RAM, 80GB SSD)$24Managed PostgreSQL (25GB)$15Managed Redis (256MB)$5Object Storage (50GB)$2Google Maps API (10k requests)$5Firebase (FCM + Analytics)Free tierSSL CertificateFree (Let's Encrypt)Total~$51/month
Revenue Model:

Subscription: Rp 50,000/month per Warung = Rp 2,500,000/month ($170/month)
Or Commission: 2% on BUMAS sales to Warungs


9. Final Recommendations
Go with Single Super App + Role Switching
Why:

Faster to market: Build once, deploy everywhere
User flexibility: Some Warung owners also do deliveries
Easier updates: No version fragmentation
Lower maintenance: One codebase to debug
Better analytics: Unified user behavior tracking

Critical Success Factors

Start Simple (MVP): Don't build everything at once. Get basic POS working first, then add features based on user feedback.
User Testing: Test with 3-5 actual Warungs before scaling. They'll find usability issues you never considered.
Performance: In Indonesia, many users have budget phones. Keep APK size under 30MB and optimize for Android 8+.
Training: Warung owners may not be tech-savvy. Build in-app tutorials and offer video guides.
Support System: WhatsApp Business API for customer support. Respond within 1 hour during business hours.

Next Immediate Steps

Week 1-2: Finalize database schema, set up development environment
Week 3-4: Build authentication + basic POS screen
Week 5-6: Implement product search and cart functionality
Week 7-8: Complete payment flow and receipt generation
Week 9-10: Admin dashboard for product catalog management
Week 11-12: User testing with pilot Warungs, bug fixes, deploy MVP


Summary
You now have a complete blueprint to build BUMAS Ansor as a cohesive Super App ecosystem. The single-app architecture with dynamic role switching gives you the agility to iterate quickly while maintaining the Shopee-like experience you're aiming for. Focus on nailing the MVP, then scale methodically based on real user needs.

----

This is an ambitious and well-structured project. Building a closed-loop ecosystem like "BUMAS Ansor" (Retail + Logistics + POS) requires a tight coupling of data but a distinct separation of user experiences.

Here is the comprehensive System Architecture and UX Design to realize your vision.

1. App Structure: Single Super App vs. Separate Apps
Recommendation: The Hybrid "Super App" Model

I strongly recommend building 1 Single Flutter Mobile App that dynamically adjusts its UI based on the logged-in user's role, paired with a Web Dashboard for the Super Admin.

Mobile App (Flutter): Serves the Warung (POS & Restocking) and the Kurir.

Web Portal (React/Vue/Angular): Serves the Super Admin. (Admins can use the mobile app for quick stats, but complex inventory/financial management is best done on a desktop screen).

Why Single App for Warung & Kurir?

Code Reusability: 80% of your code (Authentication, HTTP Client, Profile Management, Notifications, UI Components) is identical.

Deployment Ease: You only manage one bundID on the Play Store.

Flexibility: A Warung owner might also act as a Kurir in a pinch. A single app allows role-switching without re-installing apps.

How to manage "Role Switching" in Flutter:
Use a Scope or Mode state in your Provider/Riverpod/Bloc.

Login Response: Returns roles: ['WARUNG', 'KURIR'].

Home Screen: Checks the active role.

If Warung: Load PosDashboardUserWidget.

If Kurir: Load LogisticsDashboardWidget.

2. Database Design Refinement (Prisma Schema)
To handle the "Dual Role" of the Warung (buying from you, selling to customers), you need to decouple the Global Catalog from the Local Inventory.

Key Concept: The "Master vs. Instance" Pattern
Master Product (BUMAS Catalog): Defined by Super Admin.

Store Inventory (Warung Stock): The specific instance of that product in a specific Warung.

Suggested Prisma Schema (Simplified)
TypeScript
// 1. Users & Roles
model User {
  id        String   @id @default(uuid())
  email     String   @unique
  role      Role     @default(WARUNG) // ENUM: SUPER_ADMIN, WARUNG, KURIR
  store     Store?   // If role is WARUNG
  courier   Courier? // If role is KURIR
}

// 2. The Warung Entity
model Store {
  id          String          @id @default(uuid())
  userId      String          @unique
  name        String
  balance     Decimal         // Wallet for purchasing from BUMAS
  inventory   StoreProduct[]  // Their local stock
  sales       Transaction[]   // Sales to end customers
  purchases   RestockOrder[]  // Purchases from BUMAS
}

// 3. The Global Catalog (Managed by Super Admin)
model MasterProduct {
  id          String   @id @default(uuid())
  sku         String   @unique // Barcode
  name        String
  basePrice   Decimal  // Price BUMAS sells to Warung
  msrp        Decimal  // Suggested Retail Price
  description String?
  imageUrl    String?
  // Relation to local inventories
  storeProducts StoreProduct[]
}

// 4. Local Inventory (The Warung's Stock)
model StoreProduct {
  id              String         @id @default(uuid())
  storeId         String
  masterProductId String?        // Nullable if it's a "Local Only" product (e.g. Gorengan)
  
  // Customization
  customName      String?        // In case they rename it locally
  sellingPrice    Decimal        // The price Warung sells to Consumer
  stockQty        Int            // Current stock level
  
  store           Store          @relation(fields: [storeId], references: [id])
  masterProduct   MasterProduct? @relation(fields: [masterProductId], references: [id])
}

// 5. Transactions (The Dual Nature)
model Transaction {
  id        String            @id @default(uuid())
  storeId   String
  total     Decimal
  type      TransactionType   // ENUM: POS_SALE, MANUAL_ADJUSTMENT
  items     TransactionItem[]
  createdAt DateTime          @default(now())
}

model RestockOrder {
  id        String            @id @default(uuid())
  storeId   String
  courierId String?           // Assigned Kurir
  status    OrderStatus       // PENDING, PACKING, DELIVERING, COMPLETED
  total     Decimal
  items     RestockItem[]
}
Handling "Local" vs "Global" Products:

Global Products: Create a StoreProduct linked to a MasterProduct.

Local Products: Create a StoreProduct where masterProductId is NULL. This allows the Warung to sell their own items (e.g., "Es Teh Manis") that BUMAS doesn't supply.

3. User Experience (UX) Flow
A. Warung User: The "Toggle" Experience
Do not clutter the screen with both features. Use a Context Switcher (like Shopee's "Start Selling" button).

Mode 1: "Kasir" (POS Mode) - Default View

Goal: Speed and Efficiency.

UI Layout:

Top Bar: Search/Scan Barcode button.

Body: Grid of products (Categorized). Large touch targets.

Bottom Sheet: "Cart" summary with a big "CHARGE" button.

Flow: Scan Item -> Edit Qty -> Tap Charge -> Select Payment (Cash/QRIS) -> Print Receipt/WhatsApp Receipt.

Mode 2: "Kulakan" (Restock Mode) - Accessed via Menu/Profile

Goal: Discovery and Logistics tracking.

UI Layout: E-commerce style (Similar to Shopee consumer view).

Features:

Home: Banners for promos ("Diskon Minyak Goreng"), Categories.

Catalog: List of MasterProducts available from BUMAS warehouse.

Orders: Tab to track status of Restock Orders (Pending -> On Delivery).

Flow: Browse Catalog -> Add to Cart -> Checkout (Deduct Wallet balance) -> Wait for Kurir.

B. Kurir User: The "Task" Experience
The Kurir app should be "Dummy Proof." No browsing, just tasks.

Flow:

Dashboard: Shows "Current Active Jobs" map view and list view.

Job Acceptance: Admin assigns a RestockOrder to a Kurir. Notification pops up.

Pickup Phase:

Kurir goes to BUMAS Warehouse.

Scans the "Manifest QR Code" generated by Warehouse Admin.

App updates status to "Out for Delivery".

Delivery Phase:

Click "Navigate" (Opens Google Maps/Waze to Warung).

Arrive at Warung.

Handover (Proof of Delivery):

Kurir taps "Complete Delivery".

App prompts: Take Photo (goods at location) + Digital Signature (Warung owner signs on screen).

Job moves to "History".

4. Feature Roadmap (Phased Implementation)
Don't try to build everything at once. Prioritize the flow of money.

Phase 1: The "Digital Cashier" (MVP)
Focus: Get Warungs to use your POS daily. This builds habit and data.

Role: Warung Only.

Features:

POS Interface (Scan/Cart/Pay).

Product Management (CRUD Local & Global items).

Basic Sales Reports (Daily Income).

Goal: Replace their manual notebook/calculator.

Phase 2: The "Supply Chain" (Restocking)
Focus: Monetize the network by selling goods.

Role: Warung + Admin (Warehouse).

Features:

"Kulakan" Mode in App (B2B E-commerce).

Admin Dashboard to manage Stock and receive orders.

Wallet System (Warung creates a deposit balance or COD).

Phase 3: The "Logistics" (Kurir)
Focus: Optimization of delivery.

Role: Kurir.

Features:

Dedicated Driver UI.

Route Optimization.

Proof of Delivery (Photo/Signature).

Live Tracking for Warung users ("Driver is on the way").

Summary of Next Steps
Refactor NestJS: Set up the Prisma Schema to support the MasterProduct vs StoreProduct relationship.

Flutter Skeleton: Create the RoleGuard and the two distinct "Modes" (POS Widget vs Restock Widget).

Prototype: Build just the POS screen first. If the Warung can't sell easily, they won't buy from you.

---

System Architecture & UX Flow Design for "BUMAS Ansor" Super App
1. App Structure Recommendation
Recommended Approach: Single Flutter Super App with Dynamic Role-Based UI (RBAC)
For a small-to-medium retail distribution business, build one single Flutter app that dynamically changes its interface, navigation, and available features based on the user's role at login. This aligns best with your vision of a "Super App" like Shopee or Grab/Gojek, where multiple services live under one roof.
Pros of Single Super App

Lower development & maintenance cost: One codebase, one set of shared components (auth, payments, notifications, theme, utilities), one CI/CD pipeline.
Faster iteration: Bug fixes, UI improvements, and new shared features (e.g., QRIS payment gateway) are deployed once.
Better user experience for overlapping roles: A Warung owner who occasionally helps with delivery, or a Super Admin who wants to test Warung flows, can switch roles without installing multiple apps.
Smaller team burden: Easier for a small team to manage one app, especially with Flutter's hot reload and modular architecture.
Single installation & onboarding: Users download one app, log in once, and get the right experienceâ€”no confusion about which app to install.
Future-proof for expansion: Easy to add new roles/modes (e.g., customer-facing e-commerce later) as tabs or modules.

Cons (and Mitigations)

Larger app size: Mitigated by Flutter's code-splitting and lazy-loading modules. Role-specific heavy features (e.g., maps for Kurir) can be loaded only when needed.
UI complexity: Mitigated by clean architecture (see below).
Security concerns: Mitigated by strict backend RBAC enforcementâ€”never trust client-side role checks for sensitive actions.

Why Not Separate Apps?
Separate apps (Admin App, Warung/POS App, Kurir App) would give perfect isolation and smaller individual binaries, but for a small-to-medium business:

Triples deployment, testing, and store management effort.
Harder to share code and features.
Users with multiple roles need multiple apps.
Higher Play Store/App Store fees and review friction.
Most successful super apps in Southeast Asia (Grab, Gojek, Shopee) use a single consumer/partner app with role-based views, reserving separate apps only when UI/hardware needs diverge dramatically (e.g., driver apps with always-on location).

Separate apps make sense only if Kurir needs very different hardware (e.g., rugged devices) or if you anticipate millions of users and need extreme optimization.
How to Implement Role-Based UI Cleanly in Single App
Use a clean, modular Flutter architecture:
textlib/
â”œâ”€â”€ core/               # Shared (auth, theme, utils, error handling)
â”œâ”€â”€ features/
â”‚   â”œâ”€â”€ auth/           # Login, role detection
â”‚   â”œâ”€â”€ admin/          # Super Admin dashboard, overrides
â”‚   â”œâ”€â”€ warung/
â”‚   â”‚   â”œâ”€â”€ pos/        # Selling mode
â”‚   â”‚   â”œâ”€â”€ inventory/  # Stock management
â”‚   â”‚   â”œâ”€â”€ ordering/   # Restocking from BUMAS
â”‚   â”‚   â””â”€â”€ reports/
â”‚   â”œâ”€â”€ kurir/          # Delivery tasks, maps, POD
â”‚   â””â”€â”€ shared/         # Components used across roles (e.g., product card)
â”œâ”€â”€ app.dart            # Root widget that decides initial route based on role
â””â”€â”€ main.dart
Flow on Launch:

Splash â†’ Check auth token.
If logged in â†’ Fetch user profile with role(s) from backend â†’ Store in Provider/Riverpod/Bloc.
Load role-specific HomeScreen:
Super Admin â†’ Full dashboard with tabs for all roles + override tools.
Warung â†’ Bottom navigation with "Jual" (POS), "Stok", "Pesan Ulang", "Laporan".
Kurir â†’ Simple list view of today's tasks + map button.

Optional Role Switcher (for Super Admin or multi-role users): Drawer or profile page with "Switch to Warung Mode", "Switch to Kurir Mode", etc. On switch â†’ Update global state â†’ Rebuild UI with new home.

Use GoRouter or AutoRoute for declarative role-guarded routes. Enforce all sensitive actions server-side via JWT claims or role checks in NestJS guards.
2. Database Design Refinement (Prisma Schema Suggestions)
Core challenge: Warungs act as both retailers (sell to end customers, manage own stock/pricing) and buyers (restock from BUMAS main warehouse).
Key Concepts

Global Products: Central catalog managed by Super Admin (name Soms, barcode, base cost, suggested retail price).
Warung-Specific Stock: Each Warung has its own stock levels and can set custom selling prices.
Local Products (optional): Warungs can add products not in global catalog (e.g., fresh produce). Model these as regular products owned by the Warung.
Transactions: Two main types:
Sales Transactions (Warung â†’ End Customer).
Purchase Orders / Restock Transactions (Warung â†’ BUMAS Main Warehouse).


Suggested Prisma Schema (Key Models)
prismamodel User {
  id          String   @id @default(uuid())
  email       String   @unique
  name        String
  role        Role     // ENUM: SUPER_ADMIN, WARUNG, KURIR
  warungId    String?  // Null for Super Admin & Kurir, references Warung for Warung users
  warung      Warung?  @relation(fields: [warungId], references: [id])
  // ... other fields (phone, etc.)
}

model Warung {
  id          String    @id @default(uuid())
  name        String
  address     String
  users       User[]    // Multiple staff per Warung
  stocks      Stock[]
  transactions Transaction[]
  purchaseOrders PurchaseOrder[]
}

model Product {
  id              String    @id @default(uuid())
  barcode         String?   @unique
  name            String
  description     String?
  baseCost        Decimal
  suggestedPrice  Decimal?
  isGlobal        Boolean   @default(true)  // true = BUMAS catalog, false = Warung-local
  creatorWarungId String?   // Null if global
  creatorWarung   Warung?   @relation(fields: [creatorWarungId], references: [id])
  stocks          Stock[]
}

model Stock {
  id          String  @id @default(uuid())
  productId   String
  warungId    String
  quantity    Int     @default(0)
  sellingPrice Decimal // Warung can override suggested price
  product     Product @relation(fields: [productId], references: [id])
  warung      Warung  @relation(fields: [warungId], references: [id])
  @@unique([productId, warungId])
}

model Transaction {
  id          String      @id @default(uuid())
  type        TransactionType  // ENUM: SALE, RESTOCK_RECEIVE, ADJUSTMENT
  warungId    String
  warung      Warung      @relation(fields: [warungId], references: [id])
  items       TransactionItem[]
  totalAmount Decimal
  paymentMethod String?
  customerName  String?   // For sales
  createdAt   DateTime    @default(now())
}

model TransactionItem {
  id             String      @id @default(uuid())
  transactionId  String
  productId      String
  quantity       Int
  unitPrice      Decimal
  transaction    Transaction @relation(fields: [transactionId], references: [id])
}

model PurchaseOrder {
  id          String      @id @default(uuid())
  warungId    String
  warung      Warung      @relation(fields: [warungId], references: [id])
  status      OrderStatus // PENDING, CONFIRMED, DELIVERING, DELIVERED
  items       PurchaseOrderItem[]
  assignedKurirId String? 
  assignedKurir   User?       @relation(fields: [assignedKurirId], references: [id])
  createdAt   DateTime    @default(now())
}

model PurchaseOrderItem {
  // Similar to TransactionItem
}
Notes:

Main BUMAS warehouse stock can be modeled as a special "Warung" with isMainWarehouse = true or separate table if needed later.
Stock adjustments (opname) â†’ create Transaction of type ADJUSTMENT.
When a PurchaseOrder is marked DELIVERED â†’ create RESTOCK_RECEIVE Transaction and update Stock quantities.

3. User Experience (UX) Flow
Warung User Journey

Login â†’ App detects Warung role â†’ Loads bottom navigation: Jual (POS) | Stok | Pesan | Laporan.
Default Landing: Jual (POS Mode)
Quick-access barcode scanner button.
Cart view â†’ Scan/add products â†’ Apply discounts â†’ Checkout (Cash/QRIS) â†’ Print/receipt â†’ Done.

Switch to Restocking Mode
Tap "Pesan" tab â†’ Browse global catalog â†’ Add to order cart â†’ Submit PurchaseOrder â†’ View order status/history.
Notification when order is confirmed/delivered.

Switch to Stok Mode
List of current stock â†’ Search â†’ Manual adjust or Stock Opname mode (scan/count).

Reports Tab
Daily/weekly sales, profit, top products.


Mode Switching Feel: Instant tab switch, no reloadâ€”feels like mini-apps inside one.
Kurir User Journey (Simplified)

Login â†’ App detects Kurir role â†’ Simple full-screen task list ("Tugas Hari Ini").
Task List
Cards: "Ambil dari Gudang Utama â†’ Antar ke Warung X" with address, order items summary.
Status buttons: "Mulai Perjalanan" â†’ Opens maps (Google Maps/ Waze integration).

At Pickup
Scan/confirm loaded items.

At Drop-off (Warung)
Warung confirms receipt (optional signature).
Upload photo proof.
If COD, collect cash and mark paid.
Task complete â†’ Next task auto-highlighted.

End of Day
Summary screen: Tasks completed, cash collected.


UI: Minimalist, large buttons, offline-first (sync when online).
4. Feature Roadmap (Phased Implementation)
Phase 1: MVP (Core Warung Operations â€“ 3-4 months)

Auth + RBAC (Super Admin & Warung roles).
Global product catalog (Admin create, Warung browse).
Warung POS: Scan â†’ Cart â†’ Checkout (Cash/QRIS).
Basic inventory view & manual stock adjust.
Restocking: Browse â†’ Create PurchaseOrder (status pending).
Super Admin: Basic dashboard (view all Warungs, products, approve orders manually).
Basic reports (daily sales per Warung).

Phase 2: Logistics & Automation (2-3 months)

Kurir role & task assignment.
PurchaseOrder workflow: Admin confirm â†’ Assign Kurir â†’ Kurir app updates â†’ Auto stock update on delivery.
Proof of Delivery (photo + signature).
Notifications (push via Firebase).
Warung custom pricing & local products.

Phase 3: Analytics & Polish (2 months)

Advanced reports (profit margins, inventory health alerts).
Stock opname tools.
Role switcher for Super Admin.
Offline support for POS & Kurir tasks.
Audit logs & override tools for Super Admin.

Phase 4: Scale & Expansion

Multi-warehouse support.
Customer-facing features (if needed).
Analytics dashboard with charts.
Integration with external accounting systems.

Start with Phase 1 focused on Warung valueâ€”getting them selling and restocking smoothly will drive adoption fastest. Good luck with BUMAS Ansor!

---

ğŸ—ï¸ BUMAS Ansor: System Architecture & UX Design
1. App Structure Recommendation: Single Super App with Dynamic Role Switching
For a small-to-medium retail distribution business, I strongly recommend ONE Single Super App with dynamic role-based interfaces. Here's why:
âŒ Why NOT Separate Apps (Admin/POS/Driver)
Table
Copy
Issue	Impact
Maintenance Hell	3 codebases, 3 deployment pipelines, 3x bugs
User Confusion	Warung owners who also deliver need 2 apps
Update Friction	Forcing users to download multiple apps kills adoption
Code Duplication	Shared components (auth, profile, notifications) repeated
Higher Dev Cost	Small team (I assume) can't maintain 3 apps effectively
âœ… Why Single Super App Wins
Table
Copy
Advantage	Explanation
Unified Experience	One download, one login, seamless role switching
Code Reusability	Shared UI components, state management, API layer
Cross-Role Users	A Warung owner who also does delivery has everything in one place
Easier Onboarding	New users discover features organically
Faster Iteration	Single deployment cycle
The "Shopee Model" Implementation
Shopee doesn't have 3 appsâ€”they have one app with mode switching:
plain
Copy
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  BUMAS Ansor (Single App)           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ” Auth Layer (Shared)             â”‚
â”‚     â””â”€â”€ Login â†’ Role Detection      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ›ï¸ Role Switcher (Top Navigation)  â”‚
â”‚     â”œâ”€â”€ ğŸ‘‘ Owner Mode (If admin)    â”‚
â”‚     â”œâ”€â”€ ğŸª Warung Mode (If merchant)â”‚
â”‚     â””â”€â”€ ğŸšš Kurir Mode (If driver)   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ“± Feature Modules (Lazy Loaded)   â”‚
â”‚     â”œâ”€â”€ Dashboard (Role-specific)   â”‚
â”‚     â”œâ”€â”€ POS Module                  â”‚
â”‚     â”œâ”€â”€ Inventory Module            â”‚
â”‚     â”œâ”€â”€ Delivery Module             â”‚
â”‚     â””â”€â”€ Analytics Module            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Role Switching UI Pattern
Option A: Tab Bar Switcher (Recommended for MVP)
dart
Copy
// Persistent bottom navigation with role indicator
BottomNavigationBar(
  items: [
    BottomNavigationBarItem(icon: Icon(Icons.store), label: 'Warung'),
    BottomNavigationBarItem(icon: Icon(Icons.local_shipping), label: 'Kurir'),
    // Only visible if user has multiple roles
  ],
)
Option B: Drawer/Profile Switcher (Cleaner for single-role users)
dart
Copy
// In AppDrawer or Profile Page
ListTile(
  leading: Icon(Icons.switch_account),
  title: Text('Switch Mode'),
  subtitle: Text('Currently: Warung Mode'),
  onTap: () => showRoleSwitcherBottomSheet(),
)
2. Database Design Refinement (Prisma Schema)
Core Entity Relationship Diagram
plain
Copy
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     User        â”‚â”€â”€â”€â”€<â”‚   UserRole       â”‚>â”€â”€â”€â”€â”‚      Role       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ id              â”‚     â”‚ userId           â”‚     â”‚ id              â”‚
â”‚ phone           â”‚     â”‚ roleId           â”‚     â”‚ name            â”‚
â”‚ name            â”‚     â”‚ warungId (opt)   â”‚     â”‚ [OWNER,WARUNG,  â”‚
â”‚ passwordHash    â”‚     â”‚ isActive         â”‚     â”‚  KURIR]         â”‚
â”‚ createdAt       â”‚     â”‚ assignedAt       â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚  Warung (Store)  â”‚
                        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                        â”‚ id               â”‚
                        â”‚ ownerId          â”‚
                        â”‚ name             â”‚
                        â”‚ address          â”‚
                        â”‚ isActive         â”‚
                        â”‚ createdAt        â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Product & Stock Architecture
Critical Insight: You need THREE product concepts, not two:
prisma
Copy
// 1. MASTER PRODUCT (BUMAS Catalog - Single Source of Truth)
model MasterProduct {
  id          String   @id @default(uuid())
  sku         String   @unique
  name        String
  description String?
  basePrice   Decimal  @db.Decimal(12, 2)  // BUMAS selling price to Warungs
  category    String
  unit        String   // "pcs", "kg", "dozen"
  barcode     String?  @unique
  imageUrl    String?
  isActive    Boolean  @default(true)
  
  // Relationships
  warungStocks WarungStock[]  // Each warung's inventory of this product
  b2bPrices    B2BPriceTier[] // Volume pricing for restocking
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// 2. WARUNG STOCK (Inventory at each Warung location)
model WarungStock {
  id              String   @id @default(uuid())
  warungId        String
  masterProductId String
  
  // Stock Management
  quantity        Int      @default(0)     // Current available stock
  reservedQty     Int      @default(0)     // For pending orders
  reorderPoint    Int      @default(10)    // Alert when stock low
  
  // Pricing (Warung sets their own selling price)
  sellingPrice    Decimal  @db.Decimal(12, 2)
  
  // Relationships
  warung          Warung        @relation(fields: [warungId], references: [id])
  masterProduct   MasterProduct @relation(fields: [masterProductId], references: [id])
  
  // History tracking
  movements       StockMovement[]
  
  @@unique([warungId, masterProductId])
}

// 3. LOCAL PRODUCT (Warung's own products not in BUMAS catalog)
model LocalProduct {
  id          String   @id @default(uuid())
  warungId    String
  name        String
  sku         String   // Warung's internal SKU
  barcode     String?
  description String?
  costPrice   Decimal  @db.Decimal(12, 2)  // What warung paid
  sellingPrice Decimal @db.Decimal(12, 2)  // What warung sells for
  quantity    Int      @default(0)
  unit        String
  
  warung      Warung   @relation(fields: [warungId], references: [id])
  
  @@unique([warungId, sku])
}
Transaction Architecture (Dual-Purpose Design)
prisma
Copy
// Unified Transaction Model handles BOTH sales and purchases
model Transaction {
  id          String   @id @default(uuid())
  
  // Transaction Type determines the flow
  type        TransactionType // SALE_WARUNG, PURCHASE_BUMAS, ADJUSTMENT
  
  // Parties involved
  warungId    String   // Always the Warung (as seller OR buyer)
  customerId  String?  // For B2C sales (null if walk-in)
  supplierId  String?  // For B2B purchases from BUMAS
  
  // Financials
  subtotal    Decimal  @db.Decimal(12, 2)
  discount    Decimal  @default(0) @db.Decimal(12, 2)
  tax         Decimal  @default(0) @db.Decimal(12, 2)
  total       Decimal  @db.Decimal(12, 2)
  
  // Payment
  paymentMethod   PaymentMethod // CASH, QRIS, TRANSFER, COD
  paymentStatus   PaymentStatus // PENDING, PAID, PARTIAL, REFUNDED
  paidAmount      Decimal  @default(0) @db.Decimal(12, 2)
  
  // Status workflow
  status      TransactionStatus // PENDING, PROCESSING, COMPLETED, CANCELLED
  
  // For deliveries
  deliveryId  String?  // Link to delivery job if applicable
  
  // Metadata
  createdAt   DateTime @default(now())
  completedAt DateTime?
  
  // Relationships
  items       TransactionItem[]
  warung      Warung   @relation(fields: [warungId], references: [id])
}

model TransactionItem {
  id              String   @id @default(uuid())
  transactionId   String
  
  // Polymorphic reference (either MasterProduct or LocalProduct)
  productType     ProductType // MASTER or LOCAL
  productId       String      // ID of either MasterProduct or LocalProduct
  productName     String      // Snapshot at time of transaction
  sku             String      // Snapshot
  
  quantity        Int
  unitPrice       Decimal  @db.Decimal(12, 2)  // Price at transaction time
  totalPrice      Decimal  @db.Decimal(12, 2)
  
  transaction     Transaction @relation(fields: [transactionId], references: [id])
}

// Stock Movements (Audit trail for every stock change)
model StockMovement {
  id            String   @id @default(uuid())
  warungStockId String
  
  type          MovementType // SALE, PURCHASE, ADJUSTMENT, RETURN, TRANSFER_IN, TRANSFER_OUT
  
  quantity      Int      // Positive = in, Negative = out
  previousQty   Int
  newQty        Int
  
  referenceId   String?  // Link to Transaction or Adjustment
  referenceType String?  // "TRANSACTION", "ADJUSTMENT"
  
  note          String?
  createdBy     String   // User ID
  createdAt     DateTime @default(now())
  
  warungStock   WarungStock @relation(fields: [warungStockId], references: [id])
}
Delivery & Logistics Schema
prisma
Copy
model DeliveryJob {
  id          String   @id @default(uuid())
  
  // Assignment
  kurirId     String   // Assigned driver
  warungId    String   // Destination warung
  
  // Job Details
  type        DeliveryType // PICKUP_FROM_BUMAS, DELIVER_TO_WARUNG, CUSTOMER_DELIVERY
  status      DeliveryStatus // PENDING, PICKED_UP, IN_TRANSIT, DELIVERED, FAILED
  
  // Related transaction/order
  transactionId String?
  
  // Routing
  pickupAddress   String
  deliveryAddress String
  estimatedDistance Decimal? @db.Decimal(8, 2) // km
  
  // Timeline
  assignedAt    DateTime @default(now())
  pickedUpAt    DateTime?
  deliveredAt   DateTime?
  
  // Proof of Delivery
  recipientName     String?
  recipientSignature String?  // Base64 image
  deliveryPhotoUrl  String?
  notes             String?
  
  // Cash handling (for COD)
  codAmount     Decimal? @db.Decimal(12, 2)
  cashCollected Decimal? @db.Decimal(12, 2)
  
  // Relationships
  kurir         User     @relation(fields: [kurirId], references: [id])
  warung        Warung   @relation(fields: [warungId], references: [id])
}
3. User Experience (UX) Flow
ğŸª Warung User Journey: Mode Switching
plain
Copy
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  WARUNG MODE (Default Landing)                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚   ğŸ›’ POS    â”‚  â”‚ ğŸ“¦ Inventoryâ”‚  â”‚ ğŸ“Š Reports  â”‚         â”‚
â”‚  â”‚   (Sell)    â”‚  â”‚  (Manage)   â”‚  â”‚  (Analyze)  â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                             â”‚
â”‚  [Switch to Ordering Mode] â†â”€â”€ Floating Action Button       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  RESTOCKING MODE (B2B Ordering)                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  ğŸ” Search BUMAS Catalog                            â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚   â”‚
â”‚  â”‚  â”‚Product Aâ”‚ â”‚Product Bâ”‚ â”‚Product Câ”‚  ...           â”‚   â”‚
â”‚  â”‚  â”‚Rp 5.000 â”‚ â”‚Rp 12.000â”‚ â”‚Rp 8.500 â”‚               â”‚   â”‚
â”‚  â”‚  â”‚[Add +1] â”‚ â”‚[Add +1] â”‚ â”‚[Add +1] â”‚               â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  ğŸ›’ Cart (3 items)              [Checkout]          â”‚   â”‚
â”‚  â”‚  Total: Rp 125.000                                  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                             â”‚
â”‚  [Back to POS Mode]                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Key UX Patterns:
Persistent Mode Indicator: Color-coded app bar (Green = POS Mode, Blue = Restock Mode)
Quick Switch Gesture: Swipe up from bottom or double-tap app bar to switch modes
Contextual Cart: POS cart and Restock cart are separate (different use cases)
ğŸšš Kurir User Journey: Simplified Execution
plain
Copy
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  KURIR DASHBOARD (Morning Start)                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ“… Today: 16 Feb 2026                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  ğŸ¯ Active Jobs: 5                                  â”‚   â”‚
â”‚  â”‚  âœ… Completed: 2                                    â”‚   â”‚
â”‚  â”‚  ğŸ’° Cash on Hand: Rp 450.000                        â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                             â”‚
â”‚  [Start Route] â†â”€â”€ Big Primary Button                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ACTIVE DELIVERY                                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  ğŸ“ Next Stop: Warung Makmur Jaya                   â”‚   â”‚
â”‚  â”‚  ğŸ  Jl. Mawar No. 123, Jakarta Timur                â”‚   â”‚
â”‚  â”‚  ğŸ“¦ Items: 3 boxes (Rice, Oil, Sugar)               â”‚   â”‚
â”‚  â”‚  ğŸ’µ COD: Rp 250.000                                 â”‚   â”‚
â”‚  â”‚                                                     â”‚   â”‚
â”‚  â”‚  [Navigate with Maps]                               â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                             â”‚
â”‚  Status: [Picked Up] â†’ [In Transit] â†’ [Arrived]            â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  UPON ARRIVAL:                                      â”‚   â”‚
â”‚  â”‚  â˜ Get Signature                                    â”‚   â”‚
â”‚  â”‚  â˜ Take Photo                                       â”‚   â”‚
â”‚  â”‚  â˜ Collect Cash (if COD)                            â”‚   â”‚
â”‚  â”‚                                                     â”‚   â”‚
â”‚  â”‚  [âœ… Complete Delivery]                             â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Kurir UX Principles:
One Job at a Time: No multitasking, linear workflow
Large Touch Targets: Gloves-friendly buttons
Offline Capability: Cache jobs, sync when connected
Panic Button: Emergency contact if delivery fails
4. Feature Roadmap: MVP to Full Scale
Phase 1: MVP (Weeks 1-4) - "Warung Can Sell"
Goal: Warung can process basic sales
Table
Copy
Feature	Priority	Notes
Auth & Role System	ğŸ”´ Critical	Login, role detection
Warung POS (Cash Only)	ğŸ”´ Critical	Barcode scan, cart, receipt
Basic Inventory	ğŸ”´ Critical	View stock, simple adjustment
Transaction History	ğŸŸ¡ High	List view only
Super Admin Dashboard	ğŸŸ¡ High	View-only analytics
Success Metric: 10 Warungs processing 50+ transactions/day
Phase 2: Core Operations (Weeks 5-8) - "Warung Can Restock"
Goal: Complete B2B ordering loop
Table
Copy
Feature	Priority	Notes
B2B Catalog Browsing	ğŸ”´ Critical	Master product list with pricing
Restock Cart & Checkout	ğŸ”´ Critical	Order from BUMAS warehouse
Order Management (Admin)	ğŸ”´ Critical	Process B2B orders
QRIS Payment Integration	ğŸŸ¡ High	For both B2B and B2C
Basic Reporting	ğŸŸ¡ High	Daily sales summary
Success Metric: 30% of Warungs place weekly restock orders
Phase 3: Logistics (Weeks 9-12) - "Kurir Can Deliver"
Goal: End-to-end delivery tracking
Table
Copy
Feature	Priority	Notes
Kurir App (Basic)	ğŸ”´ Critical	Job list, navigation, POD
Delivery Assignment	ğŸ”´ Critical	Admin assigns jobs to Kurirs
Real-time Tracking	ğŸŸ¡ High	GPS tracking (background)
Cash Collection (COD)	ğŸŸ¡ High	Record cash, reconcile
Route Optimization	ğŸŸ¢ Medium	Basic nearest-job-first
Success Metric: 95% on-time delivery rate
Phase 4: Scale & Intelligence (Months 4-6) - "Super App Feel"
Goal: Polished, intelligent ecosystem
Table
Copy
Feature	Priority	Notes
Advanced Analytics	ğŸŸ¡ High	Predictive reorder suggestions
Loyalty Program	ğŸŸ¡ High	Points for Warungs
Multi-Warung Support	ğŸŸ¡ High	One owner, multiple locations
Automated Reordering	ğŸŸ¢ Medium	Auto-create orders at reorder point
Integration APIs	ğŸŸ¢ Medium	Connect to external accounting
5. Technical Implementation Tips
Flutter Architecture for Role Switching
dart
Copy
// main.dart
void main() {
  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => AuthProvider()),
        ChangeNotifierProvider(create: (_) => RoleProvider()),
        ChangeNotifierProxyProvider<RoleProvider, AppState>(
          create: (_) => AppState(),
          update: (_, role, appState) => appState!..updateRole(role.currentRole),
        ),
      ],
      child: BUMASAnsorApp(),
    ),
  );
}

// Role-aware router
class RoleAwareRouter extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final role = context.watch<RoleProvider>().currentRole;
    
    return Navigator(
      pages: [
        MaterialPage(child: RoleSwitcherScreen()), // Always available
        
        if (role == Role.warung) ...[
          MaterialPage(child: WarungDashboard()),
          if (mode == WarungMode.pos) MaterialPage(child: POSScreen()),
          if (mode == WarungMode.restock) MaterialPage(child: RestockScreen()),
        ],
        
        if (role == Role.kurir) 
          MaterialPage(child: KurirDashboard()),
          
        if (role == Role.owner)
          MaterialPage(child: OwnerDashboard()),
      ],
      onPopPage: (route, result) => route.didPop(result),
    );
  }
}
Backend API Design
TypeScript
Copy
// NestJS Guard for role-based access
@Injectable()
export class RoleGuard implements CanActivate {
  constructor(private reflector: Reflector) {}
  
  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<Role[]>(ROLES_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);
    
    if (!requiredRoles) return true;
    
    const { user } = context.switchToHttp().getRequest();
    return requiredRoles.some((role) => user.roles?.includes(role));
  }
}

// Controller example
@Controller('warung')
@UseGuards(JwtAuthGuard, RoleGuard)
@Roles(Role.WARUNG, Role.OWNER) // Both can access
export class WarungController {
  @Get('inventory')
  async getInventory(@CurrentUser() user: User) {
    // Return inventory for user's warung
  }
}
Summary
Table
Copy
Decision	Recommendation
App Count	1 Super App with dynamic role switching
Role Switching	Bottom nav tabs (if multi-role) or drawer menu
Product Model	MasterProduct â†’ WarungStock + LocalProduct
Transaction Model	Unified with type discriminator
First Milestone	Warung POS + Basic Inventory (4 weeks)
The "Super App" approach will save you months of development time and create a cohesive user experience that scales with your business. Start with the Warung POS as your anchor feature, then layer on restocking and logistics.