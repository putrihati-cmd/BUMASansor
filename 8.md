Rencana Aksi Produksi BUMAS Ansor (2â€“4 Minggu)
Berdasarkan analisis gap terhadap dokumen target (1.mdâ€“7.md), berikut adalah rekomendasi prioritas, strategi teknis, dan contoh konfigurasi untuk membawa proyek ke tahap siap rilis produksi.

A. Rencana Prioritas 2â€“4 Minggu (Item Tugas & Kriteria Terima)
Minggu	Fokus	Tugas	Acceptance Criteria	Risiko
1	Coverage Inti + Setup Deployment Backend	1. Unit test service modul inti: Auth, User, Product, Stock, Sales (target coverage backend 40%)
2. Integration test endpoint kritis: login, buat produk, transaksi penjualan
3. Buat docker-compose.prod.yml, nginx/nginx.conf, health.controller.ts
4. Setup GitHub Actions untuk build & push image ke registry (Docker Hub / GHCR)
5. Buat script deploy.sh dan backup-db.sh	- Backend coverage minimal 40% (setelah tambahan test)
- Docker image bisa dijalankan dengan compose produksi
- Endpoint /health merespon 200 dan menampilkan status DB/Redis
- CI publish image otomatis pada tag v*	Test memakan waktu, butuh mock yang tepat. Setup registry butuh secret.
2	Deployment Mobile + Dokumentasi Dasar	1. Finalisasi build.gradle.kts dengan flavor (dev/staging/prod) dan signing config menggunakan env
2. Setup GitHub Actions untuk build APK/AAB (debug dan release)
3. Buat docs/API.md (dari OpenAPI) dan docs/USER_MANUAL_WARUNG.md (minimal untuk role Warung)
4. Buat docs/TROUBLESHOOTING.md berisi masalah umum dan solusi	- APK debug bisa dihasilkan dari CI
- Signing config terenkripsi di GitHub Secrets
- Dokumentasi mencakup cara install, login, transaksi warung
- Troubleshooting mencakup koneksi, sync offline	Flavor dan signing di KTS butuh penyesuaian. Manual butuh validasi user.
3	Fitur Produksi & Metrik	1. Implementasi receipt printing via Bluetooth (gunakan package seperti esc_pos_bluetooth)
2. Upload bukti foto ke penyimpanan permanen (misal upload ke server, simpan path)
3. Tambahkan endpoint dashboard: omzet hari ini, piutang, laba kotor, kas/bank
4. Integrasi chart sederhana di frontend admin (gunakan fl_chart)	- Printer Bluetooth dapat mencetak struk setelah transaksi
- Foto delivery tersimpan di server dan bisa diakses
- Metrik dashboard muncul dengan data real (atau mock jika belum ada transaksi)	Hardware printer tidak selalu tersedia saat development. Integrasi chart butuh data.
4	Testing & Perbaikan Akhir	1. Jalankan E2E testing untuk alur kritis (admin buat produk â†’ kurir antar â†’ warung terima stok â†’ warung jual)
2. Uji deployment dari awal: clone repo â†’ jalankan script deploy â†’ app berfungsi
3. Perbaiki bug dan dokumentasi berdasarkan hasil uji	- Semua skenario kritis berjalan tanpa error
- Deployment script idempotent (bisa dijalankan ulang)<n>- Coverage backend â‰¥50%, mobile â‰¥40% (target realistis untuk minggu 4)	Waktu mepet, mungkin perlu prioritaskan bug blocker.
Catatan: Target coverage 80% (backend) dan 70% (mobile) sulit dicapai dalam 4 minggu jika dimulai dari 16% dan 5%. Target di atas adalah progres bertahap. Untuk go-live, coverage 50â€“60% pada modul inti sudah cukup asalkan dilengkapi dengan integration test yang memadai.

B. Strategi Test Coverage (Cepat & Efektif)
Backend (NestJS + Prisma)
Prioritas unit test (service layer):

Modul yang banyak logic bisnis: AuthService, ProductService, StockService, SalesService, FinanceService.

Gunakan mocking untuk Prisma (jest-mock-extended).

Contoh: test validasi stok, perhitungan harga, pembuatan PO.

Integration test (end-to-end):

Test endpoint kritis dengan database test terpisah (gunakan testcontainers atau database SQLite).

Fokus pada alur: login â†’ buat produk â†’ stok masuk â†’ transaksi.

Dengan ini, kita bisa sekaligus menguji controller dan prisma.

Threshold CI:

Di package.json, atur "test:cov": "jest --coverage --coverageThreshold='{\"global\":{\"lines\":50,\"branches\":40}}'" (target bertahap).

Exclude file yang tidak perlu: **/*.module.ts, **/main.ts, **/*.entity.ts, **/*.dto.ts, prisma/**/*.

Jalankan di CI hanya pada push ke branch main atau develop, bukan setiap PR.

Mobile (Flutter)
Unit test (provider/logic):

Gunakan Riverpod untuk bisnis logic; test provider dengan ProviderContainer.

Prioritaskan provider yang mengelola state penting: auth_provider, cart_provider, sync_provider.

Contoh: test login success/failure, tambah item ke cart, sinkronisasi offline.

Widget test (halaman utama):

Halaman yang sering digunakan: Login, Dashboard Admin, Warung Home, Form Transaksi.

Test dengan pumpWidget dan mock dependency (gunakan mockito).

Pastikan widget merender dengan benar dan merespon interaksi.

Integration test (driver test):

Buat satu atau dua skenario end-to-end kritis (misal login â†’ buat pesanan) dengan integration_test.

Jalankan di CI menggunakan emulator (Firebase Test Lab atau GitHub Actions dengan action futureware-tech/setup-emulator).

Coverage threshold:

Generate laporan dengan flutter test --coverage, lalu gunakan lcov untuk filter.

Di CI, fail jika coverage < 30% (dapat dinaikkan bertahap).

Exclude file otomatis: **/*.g.dart, **/*.freezed.dart, **/main.dart, **/di/*, **/generated/*.

C. Deployment Backend
Opsi Infrastruktur
Opsi	Kelebihan	Kekurangan	Rekomendasi
VPS (DigitalOcean, Linode, AWS EC2) + Docker + Nginx	- Biaya tetap murah (mulai $5/bulan)
- Kontrol penuh
- Cocok untuk monorepo	- Perlu setup manual (security, backup, monitoring)
- Tanggung jawab ops	Pilih ini karena proyek sudah punya Dockerfile dan ingin fleksibilitas.
PaaS (Railway, Render, Heroku)	- Mudah setup (integrasi git)
- Auto SSL, auto deploy	- Harga bisa mahal jika resource besar
- Keterbatasan cron job, backup	Cocok untuk staging, tapi kurang cocok untuk produksi jangka panjang dengan kebutuhan custom backup.
Minimal Konfigurasi Aman
docker-compose.prod.yml

yaml
version: '3.8'
services:
  backend:
    image: ghcr.io/username/bumas-ansor-backend:latest
    restart: always
    env_file:
      - .env.production
    depends_on:
      - postgres
      - redis
    networks:
      - app-network
    volumes:
      - uploads:/app/uploads   # untuk bukti foto

  postgres:
    image: postgres:15-alpine
    restart: always
    env_file:
      - .env.production
    volumes:
      - postgres-data:/var/lib/postgresql/data
    networks:
      - app-network

  redis:
    image: redis:7-alpine
    restart: always
    networks:
      - app-network

  nginx:
    image: nginx:alpine
    restart: always
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./ssl:/etc/nginx/ssl:ro
      - uploads:/var/www/uploads:ro
    depends_on:
      - backend
    networks:
      - app-network

volumes:
  postgres-data:
  uploads:

networks:
  app-network:
nginx/nginx.conf

nginx
events { worker_connections 1024; }

http {
  upstream backend {
    server backend:3000;
  }

  server {
    listen 80;
    server_name yourdomain.com;
    return 301 https://$server_name$request_uri;
  }

  server {
    listen 443 ssl http2;
    server_name yourdomain.com;

    ssl_certificate /etc/nginx/ssl/cert.pem;
    ssl_certificate_key /etc/nginx/ssl/key.pem;

    location /api/ {
      proxy_pass http://backend;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
    }

    location /uploads/ {
      alias /var/www/uploads/;
    }

    location /health {
      proxy_pass http://backend/health;
    }
  }
}
backend/src/health/health.controller.ts

typescript
import { Controller, Get } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { RedisService } from '../redis/redis.service';

@Controller('health')
export class HealthController {
  constructor(
    private prisma: PrismaService,
    private redis: RedisService,
  ) {}

  @Get()
  async check() {
    const dbHealthy = await this.prisma.$queryRaw`SELECT 1`.catch(() => false);
    const redisHealthy = await this.redis.ping().catch(() => false);
    return {
      status: dbHealthy && redisHealthy ? 'ok' : 'degraded',
      timestamp: new Date().toISOString(),
      services: {
        database: dbHealthy ? 'up' : 'down',
        redis: redisHealthy ? 'up' : 'down',
      },
    };
  }
}
Jangan lupa daftarkan controller di module.

backend/scripts/deploy.sh (sederhana)

bash
#!/bin/bash
set -e

echo "Pulling latest images..."
docker-compose -f docker-compose.prod.yml pull

echo "Starting services..."
docker-compose -f docker-compose.prod.yml up -d --remove-orphans

echo "Running database migrations..."
docker-compose -f docker-compose.prod.yml exec -T backend npx prisma migrate deploy

echo "Deployment complete."
backend/scripts/backup-db.sh

bash
#!/bin/bash
BACKUP_DIR=/backups
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
docker-compose -f docker-compose.prod.yml exec -T postgres pg_dump -U postgres bumastan > $BACKUP_DIR/bumastan_$TIMESTAMP.sql
# Upload ke S3 atau tempat lain (opsional)
GitHub Actions (.github/workflows/deploy.yml)

yaml
name: Deploy Backend

on:
  push:
    tags:
      - 'v*'

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Login to GHCR
        run: echo ${{ secrets.GHCR_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin
      - name: Build and push
        run: |
          docker build -t ghcr.io/username/bumas-ansor-backend:${GITHUB_REF#refs/tags/} ./backend
          docker push ghcr.io/username/bumas-ansor-backend:${GITHUB_REF#refs/tags/}
  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Deploy via SSH
        uses: appleboy/ssh-action@v0.1.5
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          script: |
            cd /opt/bumas-ansor
            docker-compose -f docker-compose.prod.yml pull
            docker-compose -f docker-compose.prod.yml up -d
            docker-compose -f docker-compose.prod.yml exec -T backend npx prisma migrate deploy
D. Deployment Mobile (Flutter)
1. Tetap Gunakan Kotlin DSL (build.gradle.kts)
Karena proyek sudah menggunakan KTS, lebih baik pertahankan untuk konsistensi. Berikut contoh konfigurasi:

mobile_app/android/app/build.gradle.kts (flavor dev, staging, production)

kotlin
android {
    compileSdk = 34

    defaultConfig {
        applicationId = "com.bumas.ansor"
        minSdk = 21
        targetSdk = 34
        versionCode = System.getenv("VERSION_CODE")?.toIntOrNull() ?: 1
        versionName = System.getenv("VERSION_NAME") ?: "1.0.0"
    }

    signingConfigs {
        create("release") {
            keyAlias = System.getenv("KEY_ALIAS")
            keyPassword = System.getenv("KEY_PASSWORD")
            storeFile = file(System.getenv("KEYSTORE_PATH") ?: "keystore.jks")
            storePassword = System.getenv("KEYSTORE_PASSWORD")
        }
    }

    buildTypes {
        release {
            signingConfig = signingConfigs.getByName("release")
            isMinifyEnabled = true
            proguardFiles(
                getDefaultProguardFile("proguard-android.txt"),
                "proguard-rules.pro"
            )
        }
    }

    flavorDimensions += "environment"
    productFlavors {
        create("dev") {
            dimension = "environment"
            applicationIdSuffix = ".dev"
            resValue("string", "app_name", "BUMAS Dev")
        }
        create("staging") {
            dimension = "environment"
            applicationIdSuffix = ".staging"
            resValue("string", "app_name", "BUMAS Staging")
        }
        create("prod") {
            dimension = "environment"
            resValue("string", "app_name", "BUMAS Ansor")
        }
    }
}
2. CI Build Artifact (GitHub Actions)
Untuk tahap awal, cukup build APK/AAB dan upload sebagai artifact agar bisa di-download dan diuji manual. Nanti jika sudah stabil, bisa integrasi dengan Play Store (fastlane).

.github/workflows/flutter-deploy.yml (sederhana)

yaml
name: Build Flutter App

on:
  push:
    tags:
      - 'mobile-v*'

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: subosito/flutter-action@v2
        with:
          flutter-version: '3.19.x'
      - run: flutter pub get
      - run: flutter test
      - name: Build APK (prod)
        env:
          KEY_ALIAS: ${{ secrets.KEY_ALIAS }}
          KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}
          KEYSTORE_PATH: /home/runner/work/keystore.jks
          KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}
        run: |
          echo "${{ secrets.KEYSTORE_BASE64 }}" | base64 --decode > /home/runner/work/keystore.jks
          flutter build apk --flavor prod --target-platform android-arm,android-arm64
      - name: Upload APK
        uses: actions/upload-artifact@v4
        with:
          name: release-apk
          path: build/app/outputs/flutter-apk/app-prod-release.apk
Catatan: Simpan keystore sebagai base64 di secret. Untuk AAB, gunakan flutter build appbundle.

3. Opsi Build ke Play Store
Gunakan fastlane untuk upload ke Play Store secara otomatis.

Butuh service account JSON dan metadata.

Untuk sekarang, build manual dulu lebih simpel.

E. Dokumentasi Minimal untuk Go-Live
1. docs/API.md
Bisa di-generate secara otomatis dari openapi.yaml menggunakan alat seperti redoc-cli atau swagger-ui. Cukup sediakan link ke file OpenAPI atau embed HTML. Contoh isi:

Pendahuluan: base URL, authentication (Bearer token).

Daftar endpoint utama per modul.

Contoh request/response.

2. docs/USER_MANUAL_WARUNG.md
Fokus pada role Warung (paling banyak digunakan). Struktur singkat:

Instalasi Aplikasi (link download APK, cara install).

Login (username/password diberikan admin).

Melihat Stok (daftar produk, jumlah).

Melakukan Penjualan (scan barcode, input jumlah, pilih metode bayar, cetak struk).

Melihat Riwayat Transaksi.

Sinkronisasi Offline (data tersimpan lokal, akan terkirim saat online).

Troubleshooting umum (tidak bisa login, data tidak sinkron).

3. docs/TROUBLESHOOTING.md
Masalah umum dan solusi cepat:

Backend 503: cek status di /health.

Mobile tidak bisa connect: periksa URL backend di pengaturan.

Database error: jalankan prisma migrate deploy.

Backup restore: cara menggunakan backup-db.sh.

Penutup
Dengan rencana di atas, tim dapat fokus pada hal-hal kritis untuk produksi dalam 2â€“4 minggu. Prioritaskan deployment backend dan dokumentasi terlebih dahulu agar sistem bisa diakses dan digunakan oleh tim internal. Setelah itu, tingkatkan coverage bertahap dan tambahkan fitur pendukung (print, foto, metrik) sesuai kebutuhan.

----------

A) RENCANA PRIORITAS 2-4 MINGGU
Minggu 1: Foundation & Critical Path
Item 1.1: Health Check + Deployment Backend Basics (2 hari)

Buat health controller, docker-compose.prod.yml, nginx.conf
AC: /health response 200, docker compose up production berjalan
Risiko: Konfigurasi secrets, port conflicts

Item 1.2: CI/CD Pipeline Backend (2 hari)

GitHub Actions deploy.yml, scripts/deploy.sh, backup-db.sh
AC: Auto-deploy ke staging, rollback bisa manual
Risiko: SSH access, environment variables management

Item 1.3: Test Coverage Backend - Critical Modules (3 hari)

Prioritas: auth, products, stocks, sales (coverage naik ke ~40-50%)
AC: Coverage badge minimal 40%, CI enforce threshold
Risiko: Mock kompleks (Prisma, Redis)

Minggu 2: Mobile Production Ready
Item 2.1: Flutter Build Setup (2 hari)

build.gradle.kts flavors (dev/staging/prod), signing config
AC: Build prod APK/AAB berhasil dengan signing
Risiko: Keystore management, flavor configuration

Item 2.2: Flutter CI/CD (2 hari)

flutter-deploy.yml, build-all.sh, fastlane basic
AC: CI build artifact tersimpan, manual upload Play Store
Risiko: Keystore di CI, build time

Item 2.3: Flutter Coverage - Provider Tests (3 hari)

Test Riverpod providers/notifiers (auth, product, stock, sales)
AC: Coverage naik ke ~40%, widget test untuk critical UI
Risiko: Mock HTTP, testing offline sync

Minggu 3: Completion & Polish
Item 3.1: Backend Coverage to 80% (3 hari)

Tambah integration tests untuk endpoints, test edge cases
AC: Coverage 80%, exclude config/dto yang wajar
Risiko: Flaky tests, slow test suite

Item 3.2: Flutter Coverage to 70% (2 hari)

Widget tests untuk screens utama, integration_test untuk flow
AC: Coverage 70%, golden tests optional
Risiko: Widget test setup complexity

Item 3.3: Dokumentasi Minimal (2 hari)

API.md (dari OpenAPI), USER_MANUAL_WARUNG.md, TROUBLESHOOTING.md
AC: Dokumen bisa dipahami user non-teknis
Risiko: Maintenance overhead

Minggu 4: Production Features & UAT
Item 4.1: Proof Storage Production (2 hari)

Upload foto delivery/payment ke S3/Cloudinary/Supabase
AC: Foto tersimpan persistent, URL accessible
Risiko: Storage cost, upload error handling

Item 4.2: Dashboard Metrics (2 hari)

Profit calculation, kas/bank balance, chart basic (Chart.js)
AC: Omzet, piutang, laba, kas muncul di dashboard
Risiko: Query performance, realtime calculation

Item 4.3: UAT + Hotfix (3 hari)

Testing oleh user, fix critical bugs
AC: 5 warung test berhasil transaksi
Risiko: Data migration, user training


B) STRATEGI TEST COVERAGE
Backend: 16% â†’ 80%
Prioritas Modul (Unit Tests):

auth.service.ts - login, register, token validation
products.service.ts - CRUD, search, stock check
stocks.service.ts - stock in/out, adjustment
sales.service.ts - create sale, payment logic
finance.service.ts - profit calculation, report

Integration Tests (E2E):

Sudah ada 31 tests âœ“ - fokus tambah edge cases
Test scenario: create order â†’ delivery â†’ payment â†’ stock update

Coverage Enforcement (jest.config.js):
json{
  "coverageThreshold": {
    "global": {
      "branches": 70,
      "functions": 75,
      "lines": 80,
      "statements": 80
    }
  },
  "coveragePathIgnorePatterns": [
    "/node_modules/",
    ".*\\.dto\\.ts$",
    ".*\\.entity\\.ts$",
    ".*\\.module\\.ts$",
    "main.ts",
    ".*\\.config\\.ts$"
  ]
}
Exclude yang wajar:

DTO/Entity (pure class)
Module files (boilerplate)
Config files
main.ts (bootstrap)

Flutter: 4.78% â†’ 70%
Prioritas Tests:

Provider/Notifier Tests (30-40% coverage bump)

auth_provider, product_provider, stock_provider, sales_provider
Mock Dio, test state changes


Widget Tests (20-30% coverage bump)

Login screen, product list, sales form
Test user interactions, validation


Integration Tests (10% coverage bump)

Flow: login â†’ scan barcode â†’ add to cart â†’ checkout



Contoh Provider Test:
dartvoid main() {
  late ProviderContainer container;
  late Dio mockDio;
  
  setUp(() {
    mockDio = MockDio();
    container = ProviderContainer(
      overrides: [dioProvider.overrideWithValue(mockDio)],
    );
  });

  test('login success updates auth state', () async {
    when(() => mockDio.post('/api/auth/login', data: any))
        .thenAnswer((_) async => Response(
          data: {'token': 'abc123'},
          statusCode: 200,
        ));
    
    await container.read(authProvider.notifier).login('user', 'pass');
    
    expect(container.read(authProvider).token, 'abc123');
  });
}
Coverage Enforcement (test/coverage_helper.dart):
dart// Exclude generated files, widgets only used for UI
// lcov_excl_start untuk bloc boilerplate

C) DEPLOYMENT BACKEND
Opsi A: VPS + Docker + Nginx (Rekomendasi)
Pros:

Full control, predictable cost (~$5-20/bulan)
Scalable, bisa tambah worker/redis
Backup database manual

Cons:

Setup awal lebih kompleks
Maintenance (OS update, security)

Opsi B: Railway/Render
Pros:

Zero config deployment
Auto SSL, monitoring
Free tier untuk testing

Cons:

Cost naik cepat ($10-50/bulan)
Vendor lock-in
Limited customization

Rekomendasi: VPS untuk produksi, Railway untuk staging
Minimal Config (VPS)
backend/docker-compose.prod.yml:
yamlversion: '3.8'
services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    environment:
      DATABASE_URL: ${DATABASE_URL}
      REDIS_URL: ${REDIS_URL}
      JWT_SECRET: ${JWT_SECRET}
    ports:
      - "3000:3000"
    depends_on:
      - postgres
      - redis
    restart: unless-stopped
    
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_DB: bumas_ansor
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped
    
  redis:
    image: redis:7-alpine
    restart: unless-stopped
    
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - app
    restart: unless-stopped

volumes:
  postgres_data:
backend/nginx/nginx.conf:
nginxevents {
    worker_connections 1024;
}

http {
    upstream backend {
        server app:3000;
    }

    server {
        listen 80;
        server_name api.bumasansor.com;
        
        # Redirect to HTTPS
        return 301 https://$server_name$request_uri;
    }

    server {
        listen 443 ssl;
        server_name api.bumasansor.com;
        
        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;
        
        client_max_body_size 10M;
        
        location / {
            proxy_pass http://backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
        
        location /health {
            proxy_pass http://backend/health;
            access_log off;
        }
    }
}
backend/scripts/deploy.sh:
bash#!/bin/bash
set -e

echo "ðŸš€ Deploying BUMAS Ansor Backend..."

# Pull latest code
git pull origin main

# Backup database
./scripts/backup-db.sh

# Build and restart
docker-compose -f docker-compose.prod.yml down
docker-compose -f docker-compose.prod.yml up -d --build

# Run migrations
docker-compose -f docker-compose.prod.yml exec -T app npx prisma migrate deploy

# Health check
sleep 10
curl -f http://localhost:3000/health || exit 1

echo "âœ… Deployment successful!"
backend/scripts/backup-db.sh:
bash#!/bin/bash
BACKUP_DIR="./backups"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="$BACKUP_DIR/backup_$TIMESTAMP.sql"

mkdir -p $BACKUP_DIR

docker-compose -f docker-compose.prod.yml exec -T postgres \
  pg_dump -U postgres bumas_ansor > $BACKUP_FILE

gzip $BACKUP_FILE

# Keep only last 7 backups
ls -t $BACKUP_DIR/*.sql.gz | tail -n +8 | xargs rm -f

echo "âœ… Backup created: $BACKUP_FILE.gz"
Health Controller
backend/src/health/health.module.ts:
typescriptimport { Module } from '@nestjs/common';
import { TerminusModule } from '@nestjs/terminus';
import { HealthController } from './health.controller';

@Module({
  imports: [TerminusModule],
  controllers: [HealthController],
})
export class HealthModule {}
backend/src/health/health.controller.ts:
typescriptimport { Controller, Get } from '@nestjs/common';
import { HealthCheck, HealthCheckService, PrismaHealthIndicator } from '@nestjs/terminus';
import { PrismaService } from '../prisma/prisma.service';

@Controller('health')
export class HealthController {
  constructor(
    private health: HealthCheckService,
    private db: PrismaHealthIndicator,
    private prisma: PrismaService,
  ) {}

  @Get()
  @HealthCheck()
  check() {
    return this.health.check([
      () => this.db.pingCheck('database', this.prisma),
    ]);
  }
}
.github/workflows/deploy.yml:
yamlname: Deploy Production

on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Deploy to VPS
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            cd /var/www/bumas-ansor
            ./backend/scripts/deploy.sh

D) DEPLOYMENT MOBILE
Rekomendasi: Tetap KTS (Kotlin DSL lebih modern, type-safe)
mobile_app/android/app/build.gradle.kts:
kotlinplugins {
    id("com.android.application")
    id("kotlin-android")
    id("dev.flutter.flutter-gradle-plugin")
}

android {
    namespace = "com.bumasansor.app"
    compileSdk = 34

    defaultConfig {
        applicationId = "com.bumasansor.app"
        minSdk = 23
        targetSdk = 34
        versionCode = flutterVersionCode.toInt()
        versionName = flutterVersionName
    }

    signingConfigs {
        create("release") {
            storeFile = file(System.getenv("KEYSTORE_FILE") ?: "keystore.jks")
            storePassword = System.getenv("KEYSTORE_PASSWORD")
            keyAlias = System.getenv("KEY_ALIAS")
            keyPassword = System.getenv("KEY_PASSWORD")
        }
    }

    flavorDimensions += "environment"
    productFlavors {
        create("dev") {
            dimension = "environment"
            applicationIdSuffix = ".dev"
            versionNameSuffix = "-dev"
            resValue("string", "app_name", "BUMAS Dev")
            buildConfigField("String", "API_URL", "\"http://10.0.2.2:3000\"")
        }
        create("staging") {
            dimension = "environment"
            applicationIdSuffix = ".staging"
            versionNameSuffix = "-staging"
            resValue("string", "app_name", "BUMAS Staging")
            buildConfigField("String", "API_URL", "\"https://staging-api.bumasansor.com\"")
        }
        create("prod") {
            dimension = "environment"
            resValue("string", "app_name", "BUMAS Ansor")
            buildConfigField("String", "API_URL", "\"https://api.bumasansor.com\"")
        }
    }

    buildTypes {
        release {
            signingConfig = signingConfigs.getByName("release")
            isMinifyEnabled = true
            isShrinkResources = true
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
}
mobile_app/android/app/proguard-rules.pro:
proguard-keep class io.flutter.app.** { *; }
-keep class io.flutter.plugin.** { *; }
-keep class io.flutter.util.** { *; }
-keep class io.flutter.view.** { *; }
-keep class io.flutter.** { *; }
-keep class com.google.firebase.** { *; }
-dontwarn io.flutter.embedding.**
mobile_app/scripts/build-all.sh:
bash#!/bin/bash
set -e

echo "ðŸ”¨ Building all flavors..."

# Clean
flutter clean
flutter pub get

# Dev APK (untuk testing internal)
flutter build apk --flavor dev --debug

# Staging APK
flutter build apk --flavor staging --release

# Production AAB (untuk Play Store)
flutter build appbundle --flavor prod --release

echo "âœ… Build complete!"
echo "ðŸ“¦ Artifacts:"
echo "  - build/app/outputs/flutter-apk/app-dev-debug.apk"
echo "  - build/app/outputs/flutter-apk/app-staging-release.apk"
echo "  - build/app/outputs/bundle/prodRelease/app-prod-release.aab"
.github/workflows/flutter-deploy.yml:
yamlname: Flutter Build & Deploy

on:
  push:
    branches: [main]
    paths:
      - 'mobile_app/**'
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - uses: actions/setup-java@v3
        with:
          distribution: 'zulu'
          java-version: '17'
      
      - uses: subosito/flutter-action@v2
        with:
          flutter-version: '3.19.0'
          channel: 'stable'
      
      - name: Install dependencies
        working-directory: mobile_app
        run: flutter pub get
      
      - name: Run tests
        working-directory: mobile_app
        run: flutter test --coverage
      
      - name: Decode keystore
        run: |
          echo "${{ secrets.KEYSTORE_BASE64 }}" | base64 -d > mobile_app/android/app/keystore.jks
      
      - name: Build AAB
        working-directory: mobile_app
        env:
          KEYSTORE_FILE: keystore.jks
          KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}
          KEY_ALIAS: ${{ secrets.KEY_ALIAS }}
          KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}
        run: flutter build appbundle --flavor prod --release
      
      - name: Upload artifact
        uses: actions/upload-artifact@v3
        with:
          name: app-prod-release.aab
          path: mobile_app/build/app/outputs/bundle/prodRelease/app-prod-release.aab
      
      # Optional: Auto-upload ke Play Store (pakai fastlane)
      # - name: Deploy to Play Store
      #   uses: r0adkll/upload-google-play@v1
      #   with:
      #     serviceAccountJsonPlainText: ${{ secrets.PLAY_STORE_JSON }}
      #     packageName: com.bumasansor.app
      #     releaseFiles: mobile_app/build/app/outputs/bundle/prodRelease/app-prod-release.aab
      #     track: internal
Rekomendasi CI: Build artifact dulu, manual upload Play Store (lebih aman untuk initial release)

E) DOKUMENTASI
Minimal Doc Set:

README.md (root) - overview, quick start
docs/API.md - endpoint reference
docs/USER_MANUAL_WARUNG.md - panduan untuk pemilik warung
docs/TROUBLESHOOTING.md - common issues

docs/API.md:
markdown# API Documentation

Base URL: `https://api.bumasansor.com`

## Authentication
All endpoints require Bearer token except `/auth/login`.

### Login
`POST /api/auth/login`
```json
{
  "username": "string",
  "password": "string"
}
```

### Products
- `GET /api/products` - List products (query: search, category)
- `GET /api/products/:id` - Get detail
- `POST /api/products` - Create (Admin only)

### Sales
- `POST /api/sales` - Create sale
```json
{
  "warungId": "uuid",
  "items": [{"productId": "uuid", "quantity": 5}],
  "paymentMethod": "CASH|BANK_TRANSFER|DEBT"
}
```

Full spec: [OpenAPI](./openapi.yaml)
docs/USER_MANUAL_WARUNG.md:
markdown# Panduan Penggunaan Aplikasi BUMAS Ansor - Warung

## 1. Login
- Buka aplikasi
- Masukkan username dan password yang diberikan Admin
- Tap "Masuk"

## 2. Melihat Stok Produk
- Di halaman utama, lihat daftar produk
- Tap produk untuk lihat detail dan stok

## 3. Membuat Penjualan
- Tap tombol "+" di pojok kanan bawah
- Scan barcode produk atau pilih manual
- Atur jumlah
- Pilih metode pembayaran (Tunai/Transfer/Hutang)
- Tap "Simpan"

## 4. Melihat Riwayat Penjualan
- Tap menu "Penjualan"
- Lihat daftar transaksi
- Tap transaksi untuk lihat detail

## 5. Hutang
- Transaksi hutang akan otomatis masuk daftar piutang
- Admin akan menagih sesuai jatuh tempo

## Troubleshooting
Lihat [TROUBLESHOOTING.md](./TROUBLESHOOTING.md)
docs/TROUBLESHOOTING.md:
markdown# Troubleshooting

## Backend

### Database Connection Error
**Gejala:** `Error: P1001: Can't reach database`
**Solusi:**
1. Cek PostgreSQL running: `docker-compose ps`
2. Cek DATABASE_URL di `.env`
3. Restart: `docker-compose restart postgres`

### Migration Failed
**Gejala:** `Migration failed to apply`
**Solusi:**
```bash
npx prisma migrate reset
npx prisma migrate deploy
```

## Mobile

### Build Failed
**Gejala:** `Gradle build failed`
**Solusi:**
1. `flutter clean`
2. `flutter pub get`
3. Delete `android/.gradle`
4. Rebuild

### Barcode Scanner Not Working
**Gejala:** Camera tidak muncul
**Solusi:**
1. Cek permission di AndroidManifest.xml
2. Restart aplikasi
3. Reinstall

### Offline Sync Conflict
**Gejala:** Data tidak sinkron setelah online
**Solusi:**
1. Logout â†’ Login ulang
2. Clear app data (Settings â†’ Apps â†’ BUMAS â†’ Clear Data)
3. Hubungi admin jika masih error

## Production

### Health Check Failed
```bash
curl https://api.bumasansor.com/health
```
Jika error 502, cek: `docker-compose logs app`

### Backup Restore
```bash
gunzip backups/backup_YYYYMMDD.sql.gz
docker-compose exec -T postgres psql -U postgres bumas_ansor < backup_YYYYMMDD.sql
```

KESIMPULAN & REKOMENDASI
Priority Order:

Week 1-2: Deployment infra + basic coverage (critical path)
Week 3: Push coverage to target (can be parallel with UAT)
Week 4: Polish + production features (optional for MVP)

Trade-offs:

Receipt printing via bluetooth: Bisa didelay (Week 4+), pakai "Copy struk" dulu
Chart dashboard: Bisa pakai library simple (chart.js), data query optimize nanti
Proof storage: Gunakan Cloudinary free tier (25 credits/bulan) untuk MVP