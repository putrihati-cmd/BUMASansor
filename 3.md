SUPER PROMPTS - BUMAS PROJECT (Per Phase)
Saya akan buatkan prompts yang bisa langsung Anda copy-paste ke AI (Cursor/Copilot/ChatGPT/Claude) untuk setiap phase.

üìã PHASE 0: PERSIAPAN
üîπ PROMPT 0.1: Project Initialization
markdownSaya ingin membuat aplikasi distribusi warung bernama BUMAS dengan tech stack:
- Backend: NestJS + TypeScript + Prisma + PostgreSQL
- Mobile: Flutter + Riverpod
- Auth: JWT
- Real-time: Socket.io

Tolong buatkan:
1. Struktur folder lengkap untuk monorepo dengan 2 folder: `backend/` dan `mobile_app/`
2. Backend NestJS dengan modules: auth, users, products, stocks, distribution, sales, finance, reports
3. File `package.json` untuk backend dengan semua dependencies yang dibutuhkan
4. File `pubspec.yaml` untuk Flutter dengan dependencies: dio, riverpod, hive, flutter_secure_storage, barcode_scanner, image_picker
5. File `.env.example` untuk environment variables
6. File `README.md` dengan instruksi setup

Format output: berikan dalam code blocks terpisah per file dengan path lengkapnya.

üîπ PROMPT 0.2: Database Schema Design
markdownSaya butuh database schema lengkap untuk sistem distribusi warung dengan fitur:

MODULES:
1. Authentication & Users (multi-role: admin, gudang, kurir, warung)
2. Master Data (products dengan barcode, categories, suppliers, warungs)
3. Inventory (multi-warehouse, stock movements, stock opname)
4. Purchase Orders (PO ke supplier, receiving)
5. Delivery Orders (DO ke warung, kurir assignment)
6. Sales/POS (transaksi warung, payment methods)
7. Finance (receivables/piutang warung, payments, credit limit)
8. Reporting (omzet, laba rugi, piutang aging)

BUSINESS RULES:
- Warung punya credit limit (Rp) dan credit days (7/14/30 hari)
- Setiap DO ke warung menambah piutang
- Payment mengurangi piutang
- Warung diblokir jika overdue > 3 hari
- Stock tracking real-time per warehouse
- Product punya margin (8-12%)
- Audit trail untuk semua transaksi

Buatkan:
1. ERD (dalam format Mermaid diagram)
2. Prisma schema lengkap dengan semua relations
3. SQL migration script untuk PostgreSQL
4. Penjelasan setiap table dan kolom penting

Pastikan ada:
- Soft delete (deletedAt)
- Timestamps (createdAt, updatedAt)
- Foreign keys dengan cascade
- Indexes untuk performa
- Enum untuk status

üîπ PROMPT 0.3: API Contract Design
markdownBuatkan REST API contract lengkap untuk sistem BUMAS dengan format OpenAPI 3.0 specification.

REQUIREMENTS:

1. AUTH ENDPOINTS:
   - POST /api/auth/register (email, password, nama, role)
   - POST /api/auth/login (return: access_token, refresh_token, user)
   - POST /api/auth/refresh
   - POST /api/auth/logout
   - GET /api/auth/me

2. PRODUCTS ENDPOINTS (CRUD + special):
   - GET /api/products (pagination, search, filter by category)
   - GET /api/products/:id
   - POST /api/products (include barcode generation)
   - PUT /api/products/:id
   - DELETE /api/products/:id (soft delete)
   - GET /api/products/barcode/:barcode

3. STOCKS ENDPOINTS:
   - GET /api/stocks (filter by warehouse, product, low stock alert)
   - POST /api/stocks/movement (in/out/transfer)
   - POST /api/stocks/opname (stock adjustment dengan alasan)
   - GET /api/stocks/history

4. DISTRIBUTION ENDPOINTS:
   - POST /api/purchase-orders (buat PO ke supplier)
   - GET /api/purchase-orders (list dengan filter status)
   - PUT /api/purchase-orders/:id/approve
   - POST /api/purchase-orders/:id/receive (update stock)
   - POST /api/delivery-orders (buat DO ke warung)
   - GET /api/delivery-orders (filter by warung, kurir, status)
   - PUT /api/delivery-orders/:id/assign-kurir
   - POST /api/delivery-orders/:id/confirm (warung confirm, update piutang)

5. SALES ENDPOINTS (POS):
   - POST /api/sales (create transaction)
   - GET /api/sales (filter by warung, date range)
   - GET /api/sales/:id (detail + receipt)
   - GET /api/sales/daily-summary

6. FINANCE ENDPOINTS:
   - GET /api/receivables (piutang per warung)
   - POST /api/payments (bayar piutang)
   - GET /api/receivables/aging (report piutang aging)
   - GET /api/receivables/warung/:id/status

7. REPORTS ENDPOINTS:
   - GET /api/reports/dashboard (omzet, piutang, laba)
   - GET /api/reports/daily (omzet, setoran, kas)
   - GET /api/reports/monthly (laba rugi, piutang, hutang)
   - GET /api/reports/top-products
   - GET /api/reports/warung-performance

Untuk setiap endpoint, sertakan:
- Method & Path
- Request body schema (jika POST/PUT)
- Query parameters (untuk filter/pagination)
- Response schema (success & error)
- Status codes
- Authentication requirement
- Role authorization

Format: gunakan YAML OpenAPI 3.0 atau JSON format yang rapi.

üèóÔ∏è PHASE 1: BACKEND FOUNDATION
üîπ PROMPT 1.1: Authentication Module (NestJS)
markdownBuatkan NestJS Authentication Module lengkap dengan fitur:

REQUIREMENTS:
1. JWT Authentication (access token + refresh token)
2. Multi-role support (admin, gudang, kurir, warung)
3. Password hashing dengan bcrypt
4. Role-based guards dan decorators
5. Refresh token rotation
6. Token blacklisting untuk logout

FILE STRUCTURE:
```
backend/src/auth/
‚îú‚îÄ‚îÄ auth.controller.ts
‚îú‚îÄ‚îÄ auth.service.ts
‚îú‚îÄ‚îÄ auth.module.ts
‚îú‚îÄ‚îÄ dto/
‚îÇ   ‚îú‚îÄ‚îÄ login.dto.ts
‚îÇ   ‚îú‚îÄ‚îÄ register.dto.ts
‚îÇ   ‚îî‚îÄ‚îÄ refresh-token.dto.ts
‚îú‚îÄ‚îÄ guards/
‚îÇ   ‚îú‚îÄ‚îÄ jwt-auth.guard.ts
‚îÇ   ‚îî‚îÄ‚îÄ roles.guard.ts
‚îú‚îÄ‚îÄ decorators/
‚îÇ   ‚îú‚îÄ‚îÄ current-user.decorator.ts
‚îÇ   ‚îî‚îÄ‚îÄ roles.decorator.ts
‚îî‚îÄ‚îÄ strategies/
    ‚îú‚îÄ‚îÄ jwt.strategy.ts
    ‚îî‚îÄ‚îÄ jwt-refresh.strategy.ts
```

ENDPOINTS:
- POST /auth/register
- POST /auth/login
- POST /auth/refresh
- POST /auth/logout
- GET /auth/me

SECURITY:
- JWT expiry: access 15 min, refresh 7 days
- Bcrypt salt rounds: 10
- Secure httpOnly cookies untuk refresh token
- Rate limiting untuk login attempts

Buatkan semua file lengkap dengan:
1. TypeScript types
2. Validation dengan class-validator
3. Error handling proper
4. Response interceptor
5. Unit test untuk auth.service.ts

GUNAKAN PRISMA untuk database operations dengan model:
```prisma
model User {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String
  name      String
  role      Role
  warungId  String?
  warung    Warung?  @relation(fields: [warungId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum Role {
  ADMIN
  GUDANG
  KURIR
  WARUNG
}
```

Berikan code lengkap untuk setiap file!

üîπ PROMPT 1.2: Products & Master Data Module
markdownBuatkan NestJS Module untuk Master Data Management:

MODULES YANG DIBUTUHKAN:
1. Products Module
2. Categories Module
3. Suppliers Module
4. Warungs Module

PRISMA MODELS:
```prisma
model Product {
  id          String    @id @default(uuid())
  name        String
  barcode     String    @unique
  categoryId  String
  category    Category  @relation(fields: [categoryId], references: [id])
  buyPrice    Decimal   @db.Decimal(10, 2)
  sellPrice   Decimal   @db.Decimal(10, 2)
  margin      Decimal   @db.Decimal(5, 2)
  unit        String    // pcs, pack, karton, dll
  description String?
  imageUrl    String?
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?
}

model Category {
  id        String    @id @default(uuid())
  name      String
  products  Product[]
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
}

model Supplier {
  id          String   @id @default(uuid())
  name        String
  contact     String
  phone       String
  address     String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Warung {
  id              String   @id @default(uuid())
  name            String
  ownerName       String
  phone           String
  address         String
  creditLimit     Decimal  @db.Decimal(12, 2)
  creditDays      Int      // 7, 14, atau 30
  currentDebt     Decimal  @db.Decimal(12, 2) @default(0)
  isBlocked       Boolean  @default(false)
  blockedReason   String?
  latitude        Float?
  longitude       Float?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  deletedAt       DateTime?
}
```

FITUR PRODUCTS MODULE:
1. CRUD operations
2. Auto-generate barcode jika belum ada (format: BMXXXXX, random 5 digit)
3. Calculate margin otomatis dari buyPrice & sellPrice
4. Soft delete
5. Search by name/barcode
6. Filter by category, isActive
7. Pagination (10, 25, 50, 100 per page)
8. Bulk import dari Excel/CSV
9. Export to Excel

FITUR WARUNGS MODULE:
1. CRUD operations
2. Set/Update credit limit
3. Block/Unblock warung
4. Check credit status (available credit = limit - currentDebt)
5. Warung map view (latitude/longitude)
6. Filter by blocked status, region

DTO REQUIREMENTS:
- CreateProductDto dengan validation (@IsString, @IsNumber, @Min, @Max)
- UpdateProductDto (partial dari create)
- QueryProductDto untuk filter & pagination
- Response DTOs dengan exclude password/sensitive data

ENDPOINTS:
Products:
- GET /api/products
- GET /api/products/:id
- POST /api/products
- PUT /api/products/:id
- DELETE /api/products/:id
- GET /api/products/barcode/:barcode
- POST /api/products/bulk-import
- GET /api/products/export

Warungs:
- GET /api/warungs
- GET /api/warungs/:id
- POST /api/warungs
- PUT /api/warungs/:id
- PUT /api/warungs/:id/block
- PUT /api/warungs/:id/unblock
- GET /api/warungs/:id/credit-status

AUTHORIZATION:
- Admin: full access
- Gudang: read-only products
- Warung: read-only own data
- Kurir: read warung data only

Berikan code lengkap untuk semua files dengan proper error handling!

üîπ PROMPT 1.3: Inventory Management Module
markdownBuatkan NestJS Inventory Management Module dengan multi-warehouse support.

PRISMA MODELS:
```prisma
model Warehouse {
  id        String   @id @default(uuid())
  name      String
  location  String
  phone     String
  stocks    Stock[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Stock {
  id          String      @id @default(uuid())
  warehouseId String
  warehouse   Warehouse   @relation(fields: [warehouseId], references: [id])
  productId   String
  product     Product     @relation(fields: [productId], references: [id])
  quantity    Int         @default(0)
  minStock    Int         @default(10) // untuk alert
  updatedAt   DateTime    @updatedAt
  
  @@unique([warehouseId, productId])
}

model StockMovement {
  id              String          @id @default(uuid())
  movementType    MovementType
  productId       String
  product         Product         @relation(fields: [productId], references: [id])
  fromWarehouseId String?
  fromWarehouse   Warehouse?      @relation("from", fields: [fromWarehouseId], references: [id])
  toWarehouseId   String?
  toWarehouse     Warehouse?      @relation("to", fields: [toWarehouseId], references: [id])
  quantity        Int
  referenceType   String?         // 'PO', 'DO', 'SALES', 'ADJUSTMENT'
  referenceId     String?
  notes           String?
  createdBy       String
  createdByUser   User            @relation(fields: [createdBy], references: [id])
  createdAt       DateTime        @default(now())
}

enum MovementType {
  IN              // barang masuk (dari supplier)
  OUT             // barang keluar (ke warung)
  TRANSFER        // transfer antar gudang
  ADJUSTMENT      // penyesuaian stok opname
}

model StockOpname {
  id          String   @id @default(uuid())
  warehouseId String
  warehouse   Warehouse @relation(fields: [warehouseId], references: [id])
  productId   String
  product     Product   @relation(fields: [productId], references: [id])
  systemQty   Int      // qty di sistem
  actualQty   Int      // qty hasil hitung fisik
  difference  Int      // selisih
  reason      String   // alasan adjustment
  performedBy String
  user        User     @relation(fields: [performedBy], references: [id])
  createdAt   DateTime @default(now())
}
```

FITUR:
1. Real-time stock tracking per warehouse per product
2. Stock movement recording (IN/OUT/TRANSFER/ADJUSTMENT)
3. Stock opname (physical count & adjustment)
4. Low stock alerts (jika qty < minStock)
5. Stock history & audit trail
6. Multi-warehouse transfer
7. Stock valuation (qty √ó buyPrice)

BUSINESS LOGIC:
- Setiap movement harus update table Stock
- IN movement: tambah qty
- OUT movement: kurangi qty (cek ketersediaan dulu)
- TRANSFER: kurangi dari warehouse asal, tambah ke tujuan
- ADJUSTMENT: sesuaikan qty berdasarkan opname
- Simpan semua movement ke StockMovement untuk audit

ENDPOINTS:
- GET /api/stocks (filter: warehouse, product, lowStock)
- GET /api/stocks/:warehouseId/:productId
- POST /api/stocks/movement (record stock in/out/transfer)
- POST /api/stocks/opname (perform stock count & adjustment)
- GET /api/stocks/movements (history dengan filter)
- GET /api/stocks/alerts (list produk dengan qty < minStock)
- GET /api/stocks/valuation (total nilai stok)

DTO:
```typescript
class StockMovementDto {
  @IsEnum(MovementType)
  movementType: MovementType;
  
  @IsUUID()
  productId: string;
  
  @IsInt()
  @Min(1)
  quantity: number;
  
  @IsOptional()
  @IsUUID()
  fromWarehouseId?: string;
  
  @IsOptional()
  @IsUUID()
  toWarehouseId?: string;
  
  @IsOptional()
  @IsString()
  notes?: string;
}

class StockOpnameDto {
  @IsUUID()
  warehouseId: string;
  
  @IsUUID()
  productId: string;
  
  @IsInt()
  actualQty: number;
  
  @IsString()
  reason: string;
}
```

ERROR HANDLING:
- Throw BadRequestException jika OUT quantity > available stock
- Throw NotFoundException jika product/warehouse not found
- Use database transaction untuk movement (update Stock + insert StockMovement)

AUTHORIZATION:
- Admin & Gudang: full access
- Kurir: read-only
- Warung: no access

Berikan code lengkap dengan service logic, controller, dan unit tests!

üîπ PROMPT 1.4: Purchase Order & Delivery Order Module
markdownBuatkan NestJS Module untuk Purchase Order (PO) dan Delivery Order (DO) dengan workflow lengkap.

PRISMA MODELS:
```prisma
model PurchaseOrder {
  id          String        @id @default(uuid())
  poNumber    String        @unique // auto-generate: PO-YYYYMMDD-XXX
  supplierId  String
  supplier    Supplier      @relation(fields: [supplierId], references: [id])
  warehouseId String
  warehouse   Warehouse     @relation(fields: [warehouseId], references: [id])
  items       POItem[]
  totalAmount Decimal       @db.Decimal(12, 2)
  status      POStatus      @default(PENDING)
  notes       String?
  createdBy   String
  user        User          @relation(fields: [createdBy], references: [id])
  approvedBy  String?
  approvedAt  DateTime?
  receivedBy  String?
  receivedAt  DateTime?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
}

model POItem {
  id        String        @id @default(uuid())
  poId      String
  po        PurchaseOrder @relation(fields: [poId], references: [id], onDelete: Cascade)
  productId String
  product   Product       @relation(fields: [productId], references: [id])
  quantity  Int
  price     Decimal       @db.Decimal(10, 2)
  subtotal  Decimal       @db.Decimal(12, 2)
}

enum POStatus {
  PENDING
  APPROVED
  RECEIVED
  CANCELLED
}

model DeliveryOrder {
  id          String     @id @default(uuid())
  doNumber    String     @unique // auto-generate: DO-YYYYMMDD-XXX
  warungId    String
  warung      Warung     @relation(fields: [warungId], references: [id])
  kurirId     String?
  kurir       User?      @relation("kurir", fields: [kurirId], references: [id])
  items       DOItem[]
  totalAmount Decimal    @db.Decimal(12, 2)
  status      DOStatus   @default(PENDING)
  creditDays  Int        // 7, 14, atau 30
  dueDate     DateTime   // calculatedAt create
  notes       String?
  createdBy   String
  user        User       @relation("creator", fields: [createdBy], references: [id])
  assignedAt  DateTime?
  deliveredAt DateTime?
  confirmedBy String?
  confirmedAt DateTime?
  photoProof  String?    // URL foto bukti terima
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
}

model DOItem {
  id        String        @id @default(uuid())
  doId      String
  do        DeliveryOrder @relation(fields: [doId], references: [id], onDelete: Cascade)
  productId String
  product   Product       @relation(fields: [productId], references: [id])
  quantity  Int
  price     Decimal       @db.Decimal(10, 2)
  subtotal  Decimal       @db.Decimal(12, 2)
}

enum DOStatus {
  PENDING
  ASSIGNED
  ON_DELIVERY
  DELIVERED
  CONFIRMED
  CANCELLED
}
```

FITUR PURCHASE ORDER:
1. Create PO (admin/gudang)
2. Auto-generate PO number
3. Calculate total amount dari items
4. Approve PO (admin only)
5. Receive goods (gudang)
   - Update stock IN
   - Record stock movement
   - Change status to RECEIVED
6. Cancel PO (jika masih PENDING)

FITUR DELIVERY ORDER:
1. Create DO (admin)
2. Auto-generate DO number
3. Check credit limit warung sebelum buat DO
4. Calculate due date (createdAt + creditDays)
5. Assign kurir (admin/gudang)
6. Update status saat kurir deliver
7. Warung confirm penerimaan (dengan foto bukti)
8. Auto-create receivable saat confirmed
9. Cancel DO (jika masih PENDING/ASSIGNED)

BUSINESS LOGIC:
PO Flow:
1. Admin buat PO ‚Üí status: PENDING
2. Admin approve ‚Üí status: APPROVED
3. Gudang terima barang ‚Üí status: RECEIVED
   - Update Stock (movement type: IN)
   - Record to StockMovement

DO Flow:
1. Admin buat DO ‚Üí check credit limit
   - available = warung.creditLimit - warung.currentDebt
   - if (DO.totalAmount > available) ‚Üí throw error
2. Admin assign kurir ‚Üí status: ASSIGNED
3. Kurir ambil barang ‚Üí status: ON_DELIVERY
4. Kurir deliver ‚Üí status: DELIVERED
5. Warung confirm (upload foto) ‚Üí status: CONFIRMED
   - Update Stock (movement type: OUT)
   - Create Receivable
   - Update warung.currentDebt += totalAmount

ENDPOINTS:
Purchase Orders:
- POST /api/purchase-orders (create)
- GET /api/purchase-orders (list dengan filter)
- GET /api/purchase-orders/:id
- PUT /api/purchase-orders/:id/approve
- POST /api/purchase-orders/:id/receive
- DELETE /api/purchase-orders/:id (cancel)

Delivery Orders:
- POST /api/delivery-orders (create)
- GET /api/delivery-orders (filter by status, warung, kurir)
- GET /api/delivery-orders/:id
- PUT /api/delivery-orders/:id/assign-kurir
- PUT /api/delivery-orders/:id/start-delivery
- POST /api/delivery-orders/:id/confirm (warung confirm dengan foto)
- DELETE /api/delivery-orders/:id (cancel)

DTO:
```typescript
class CreatePODto {
  @IsUUID()
  supplierId: string;
  
  @IsUUID()
  warehouseId: string;
  
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => POItemDto)
  items: POItemDto[];
  
  @IsOptional()
  @IsString()
  notes?: string;
}

class POItemDto {
  @IsUUID()
  productId: string;
  
  @IsInt()
  @Min(1)
  quantity: number;
  
  @IsNumber()
  @Min(0)
  price: number;
}

class CreateDODto {
  @IsUUID()
  warungId: string;
  
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => DOItemDto)
  items: DOItemDto[];
  
  @IsInt()
  @IsIn([7, 14, 30])
  creditDays: number;
  
  @IsOptional()
  @IsString()
  notes?: string;
}

class ConfirmDODto {
  @IsString()
  photoProof: string; // base64 atau URL
}
```

AUTHORIZATION:
PO:
- Admin: full access
- Gudang: create, receive
- Kurir, Warung: no access

DO:
- Admin: full access
- Gudang: read, assign kurir
- Kurir: read assigned DO, update status
- Warung: read own DO, confirm delivery

ERROR HANDLING:
- Throw jika credit limit exceeded
- Throw jika stock insufficient (untuk DO)
- Throw jika PO/DO not found
- Use transaction untuk multi-table updates

Berikan code lengkap dengan services, controllers, dan database transactions!

üîπ PROMPT 1.5: Sales/POS Module
markdownBuatkan NestJS Sales/POS Module untuk transaksi penjualan warung.

PRISMA MODELS:
```prisma
model Sale {
  id            String        @id @default(uuid())
  saleNumber    String        @unique // auto: SALE-YYYYMMDD-XXX
  warungId      String
  warung        Warung        @relation(fields: [warungId], references: [id])
  items         SaleItem[]
  subtotal      Decimal       @db.Decimal(12, 2)
  discount      Decimal       @db.Decimal(12, 2) @default(0)
  tax           Decimal       @db.Decimal(12, 2) @default(0)
  totalAmount   Decimal       @db.Decimal(12, 2)
  paymentMethod PaymentMethod
  cashReceived  Decimal?      @db.Decimal(12, 2) // jika cash
  cashChange    Decimal?      @db.Decimal(12, 2) // jika cash
  paymentProof  String?       // jika transfer
  notes         String?
  cashierId     String
  cashier       User          @relation(fields: [cashierId], references: [id])
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
}

model SaleItem {
  id         String  @id @default(uuid())
  saleId     String
  sale       Sale    @relation(fields: [saleId], references: [id], onDelete: Cascade)
  productId  String
  product    Product @relation(fields: [productId], references: [id])
  quantity   Int
  price      Decimal @db.Decimal(10, 2)
  discount   Decimal @db.Decimal(10, 2) @default(0)
  subtotal   Decimal @db.Decimal(12, 2)
}

enum PaymentMethod {
  CASH
  TRANSFER
  QRIS
  EDC
}
```

FITUR:
1. Create sale transaction
2. Auto-generate sale number
3. Support multiple payment methods
4. Calculate subtotal, discount, tax, total
5. Update stock OUT untuk setiap item
6. Generate receipt (text/image)
7. Sale history dengan filter
8. Daily sales summary
9. Void/cancel transaction (dalam waktu tertentu)

BUSINESS LOGIC:
Create Sale Flow:
1. Validate semua products tersedia di stock warung
2. Check stock availability untuk setiap item
3. Calculate totals:
   - subtotal = Œ£(item.price √ó item.quantity - item.discount)
   - tax = subtotal √ó 0 (atau sesuai aturan pajak)
   - totalAmount = subtotal - discount + tax
4. If payment method = CASH:
   - Validate cashReceived >= totalAmount
   - Calculate cashChange = cashReceived - totalAmount
5. Create Sale record
6. Update Stock OUT untuk setiap item (via StockMovement)
7. Return sale dengan receipt data

Receipt Format:
```
========================================
           WARUNG BERKAH
      Jl. Sudirman No. 123
         Telp: 0281-123456
========================================
Sale #: SALE-20240315-001
Date  : 15 Mar 2024 14:30
Cashier: Ahmad

----------------------------------------
Item                  Qty   Price  Total
----------------------------------------
Indomie Goreng         5   3,000  15,000
Gula Pasir 1kg         2  15,000  30,000
Minyak Goreng 2L       1  30,000  30,000
----------------------------------------
Subtotal:                          75,000
Discount:                               0
Tax:                                    0
----------------------------------------
TOTAL:                             75,000

Payment: CASH
Received:                         100,000
Change:                            25,000

========================================
    Terima kasih atas kunjungan Anda
         ~ BUMAS Ansor Banyumas ~
========================================
```

ENDPOINTS:
- POST /api/sales (create transaction)
- GET /api/sales (list dengan pagination & filter)
- GET /api/sales/:id (detail + receipt)
- GET /api/sales/daily-summary (omzet hari ini)
- GET /api/sales/receipt/:id (generate receipt text)
- POST /api/sales/:id/void (cancel transaction)

DTO:
```typescript
class CreateSaleDto {
  @IsUUID()
  warungId: string;
  
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => SaleItemDto)
  items: SaleItemDto[];
  
  @IsNumber()
  @Min(0)
  discount: number;
  
  @IsEnum(PaymentMethod)
  paymentMethod: PaymentMethod;
  
  @IsOptional()
  @IsNumber()
  cashReceived?: number;
  
  @IsOptional()
  @IsString()
  paymentProof?: string;
  
  @IsOptional()
  @IsString()
  notes?: string;
}

class SaleItemDto {
  @IsUUID()
  productId: string;
  
  @IsInt()
  @Min(1)
  quantity: number;
  
  @IsNumber()
  @Min(0)
  price: number;
  
  @IsOptional()
  @IsNumber()
  @Min(0)
  discount?: number;
}

class DailySummaryDto {
  @IsDateString()
  date: string; // YYYY-MM-DD
}
```

RESPONSE:
```typescript
interface SaleResponse {
  id: string;
  saleNumber: string;
  warung: {
    id: string;
    name: string;
  };
  items: {
    product: {
      id: string;
      name: string;
    };
    quantity: number;
    price: number;
    discount: number;
    subtotal: number;
  }[];
  subtotal: number;
  discount: number;
  tax: number;
  totalAmount: number;
  paymentMethod: string;
  cashReceived?: number;
  cashChange?: number;
  createdAt: string;
}

interface DailySummaryResponse {
  date: string;
  totalSales: number;
  totalTransactions: number;
  totalItems: number;
  paymentMethodBreakdown: {
    CASH: number;
    TRANSFER: number;
    QRIS: number;
    EDC: number;
  };
}
```

AUTHORIZATION:
- Warung: create sale untuk warung sendiri, view own sales
- Admin & Gudang: view all sales
- Kurir: no access

ERROR HANDLING:
- Throw jika stock insufficient
- Throw jika cashReceived < totalAmount (untuk CASH)
- Use database transaction untuk sale + stock update

ADDITIONAL FEATURES:
1. Void transaction (hanya dalam 24 jam)
2. Export sales to Excel
3. Top selling products
4. Sales by time (hourly breakdown)

Berikan code lengkap dengan service, controller, receipt generator, dan tests!

üîπ PROMPT 1.6: Finance Module (Receivables & Payments)
markdownBuatkan NestJS Finance Module untuk manajemen piutang (receivables) dan pembayaran.

PRISMA MODELS:
```prisma
model Receivable {
  id          String            @id @default(uuid())
  invoiceNo   String            @unique // auto: INV-YYYYMMDD-XXX
  warungId    String
  warung      Warung            @relation(fields: [warungId], references: [id])
  doId        String
  do          DeliveryOrder     @relation(fields: [doId], references: [id])
  amount      Decimal           @db.Decimal(12, 2)
  paid        Decimal           @db.Decimal(12, 2) @default(0)
  balance     Decimal           @db.Decimal(12, 2) // amount - paid
  dueDate     DateTime
  status      ReceivableStatus  @default(UNPAID)
  payments    Payment[]
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
}

enum ReceivableStatus {
  UNPAID
  PARTIAL
  PAID
  OVERDUE
}

model Payment {
  id            String      @id @default(uuid())
  paymentNo     String      @unique // auto: PAY-YYYYMMDD-XXX
  receivableId  String
  receivable    Receivable  @relation(fields: [receivableId], references: [id])
  amount        Decimal     @db.Decimal(12, 2)
  paymentMethod PaymentMethod
  paymentProof  String?     // foto bukti transfer
  notes         String?
  verifiedBy    String?
  verifiedAt    DateTime?
  createdBy     String
  user          User        @relation(fields: [createdBy], references: [id])
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
}
```

FITUR:
1. Auto-create receivable saat DO confirmed
2. Record payment (warung bayar piutang)
3. Verify payment (admin)
4. Calculate aging (berapa hari belum bayar)
5. Auto-update receivable status
6. Block warung jika overdue > 3 hari
7. Unblock warung saat lunas
8. Payment history
9. Receivable aging report

BUSINESS LOGIC:

Create Receivable (dipanggil dari DO confirm):
```typescript
async createReceivable(do: DeliveryOrder) {
  const receivable = await prisma.receivable.create({
    data: {
      invoiceNo: generateInvoiceNo(),
      warungId: do.warungId,
      doId: do.id,
      amount: do.totalAmount,
      balance: do.totalAmount,
      dueDate: do.dueDate,
      status: 'UNPAID'
    }
  });
  
  // Update warung currentDebt
  await prisma.warung.update({
    where: { id: do.warungId },
    data: {
      currentDebt: {
        increment: do.totalAmount
      }
    }
  });
  
  return receivable;
}
```

Record Payment:
```typescript
async recordPayment(data: CreatePaymentDto) {
  return await prisma.$transaction(async (tx) => {
    // Create payment
    const payment = await tx.payment.create({
      data: {
        paymentNo: generatePaymentNo(),
        receivableId: data.receivableId,
        amount: data.amount,
        paymentMethod: data.paymentMethod,
        paymentProof: data.paymentProof,
        notes: data.notes,
        createdBy: data.userId,
      }
    });
    
    // Update receivable
    const receivable = await tx.receivable.update({
      where: { id: data.receivableId },
      data: {
        paid: { increment: data.amount },
        balance: { decrement: data.amount }
      },
      include: { warung: true }
    });
    
    // Update status
    const newStatus = 
      receivable.balance === 0 ? 'PAID' :
      receivable.paid > 0 ? 'PARTIAL' :
      'UNPAID';
    
    await tx.receivable.update({
      where: { id: data.receivableId },
      data: { status: newStatus }
    });
    
    // Update warung currentDebt
    await tx.warung.update({
      where: { id: receivable.warungId },
      data: {
        currentDebt: { decrement: data.amount }
      }
    });
    
    // Check if should unblock warung
    if (newStatus === 'PAID') {
      const overdueCount = await tx.receivable.count({
        where: {
          warungId: receivable.warungId,
          status: 'OVERDUE'
        }
      });
      
      if (overdueCount === 0) {
        await tx.warung.update({
          where: { id: receivable.warungId },
          data: {
            isBlocked: false,
            blockedReason: null
          }
        });
      }
    }
    
    return payment;
  });
}
```

Check & Update Overdue (Cron Job - daily):
```typescript
async updateOverdueStatus() {
  const today = new Date();
  
  // Find unpaid/partial yang lewat due date
  const overdues = await prisma.receivable.findMany({
    where: {
      status: { in: ['UNPAID', 'PARTIAL'] },
      dueDate: { lt: today }
    },
    include: { warung: true }
  });
  
  for (const receivable of overdues) {
    // Update status to OVERDUE
    await prisma.receivable.update({
      where: { id: receivable.id },
      data: { status: 'OVERDUE' }
    });
    
    // Calculate days overdue
    const daysOverdue = Math.floor(
      (today.getTime() - receivable.dueDate.getTime()) / (1000 * 60 * 60 * 24)
    );
    
    // Block warung if overdue > 3 days
    if (daysOverdue > 3 && !receivable.warung.isBlocked) {
      await prisma.warung.update({
        where: { id: receivable.warungId },
        data: {
          isBlocked: true,
          blockedReason: `Overdue payment: ${daysOverdue} days`
        }
      });
    }
  }
}
```

ENDPOINTS:
Receivables:
- GET /api/receivables (filter: warung, status, overdue)
- GET /api/receivables/:id
- GET /api/receivables/warung/:warungId (list piutang warung)
- GET /api/receivables/aging (report aging)
- GET /api/receivables/summary (total unpaid, partial, overdue)

Payments:
- POST /api/payments (warung bayar)
- GET /api/payments (history)
- GET /api/payments/:id
- PUT /api/payments/:id/verify (admin verify)
- GET /api/payments/warung/:warungId (payment history warung)

DTO:
```typescript
class CreatePaymentDto {
  @IsUUID()
  receivableId: string;
  
  @IsNumber()
  @Min(0)
  amount: number;
  
  @IsEnum(PaymentMethod)
  paymentMethod: PaymentMethod;
  
  @IsOptional()
  @IsString()
  paymentProof?: string; // base64 image
  
  @IsOptional()
  @IsString()
  notes?: string;
}

class QueryReceivableDto {
  @IsOptional()
  @IsUUID()
  warungId?: string;
  
  @IsOptional()
  @IsEnum(ReceivableStatus)
  status?: ReceivableStatus;
  
  @IsOptional()
  @IsBoolean()
  overdueOnly?: boolean;
  
  @IsOptional()
  @IsInt()
  page?: number = 1;
  
  @IsOptional()
  @IsInt()
  limit?: number = 10;
}
```

RESPONSE:
```typescript
interface AgingReportResponse {
  current: number;      // belum jatuh tempo
  days1to30: number;    // 1-30 hari lewat
  days31to60: number;   // 31-60 hari lewat
  days61to90: number;   // 61-90 hari lewat
  above90: number;      // > 90 hari lewat
  total: number;
}

interface ReceivableSummaryResponse {
  totalReceivables: number;
  totalUnpaid: number;
  totalPartial: number;
  totalOverdue: number;
  totalPaid: number;
}
```

AUTHORIZATION:
- Admin: full access
- Warung: view own receivables, create payment
- Gudang: view all, verify payment
- Kurir: no access

SCHEDULER:
Buat cron job untuk check overdue setiap hari jam 00:01:
```typescript
@Cron('1 0 * * *') // every day at 00:01
async handleOverdueCheck() {
  await this.financeService.updateOverdueStatus();
}
```

ADDITIONAL FEATURES:
1. Payment reminder notification (H-3, H-1, H+1)
2. Export aging report to Excel
3. Payment receipt generator
4. Bulk payment upload (Excel)

Berikan code lengkap dengan services, controllers, cron jobs, dan tests!

üîπ PROMPT 1.7: Reporting & Dashboard Module
markdownBuatkan NestJS Reporting Module untuk dashboard dan laporan lengkap.

FITUR REPORTS:
1. Dashboard Overview (real-time)
2. Daily Report (omzet, setoran, kas)
3. Monthly Report (laba rugi, piutang, hutang)
4. Product Performance (top selling, slow moving)
5. Warung Performance (omzet per warung, payment behavior)
6. Stock Report (valuation, movement)
7. Finance Report (receivables aging, cash flow)

ENDPOINTS:

Dashboard:
- GET /api/reports/dashboard
Response:
```typescript
interface DashboardResponse {
  today: {
    omzet: number;          // total sales today
    piutangBelumLunas: number;
    labaHariIni: number;    // omzet - hpp
    kasBank: number;
  };
  chart: {
    omzetBulanan: {
      labels: string[];     // ['Jan', 'Feb', ...]
      omzet: number[];
      pengeluaran: number[];
    };
  };
  warung: {
    totalAktif: number;
    totalBlocked: number;
  };
  stocks: {
    lowStockCount: number;
    totalValue: number;
  };
  topProducts: {
    productId: string;
    productName: string;
    totalSold: number;
    revenue: number;
  }[];
}
```

Daily Report:
- GET /api/reports/daily?date=2024-03-15
Response:
```typescript
interface DailyReportResponse {
  date: string;
  omzet: {
    totalSales: number;
    totalTransactions: number;
    averageTransaction: number;
  };
  setoran: {
    cash: number;
    transfer: number;
    total: number;
  };
  kas: {
    beginning: number;
    income: number;      // setoran + payment
    expense: number;     // pembelian, operasional
    ending: number;
  };
  topProducts: {
    productName: string;
    quantity: number;
    revenue: number;
  }[];
}
```

Monthly Report:
- GET /api/reports/monthly?month=2024-03
Response:
```typescript
interface MonthlyReportResponse {
  month: string;
  labaRugi: {
    revenue: number;        // total sales
    hpp: number;            // harga pokok penjualan
    grossProfit: number;    // revenue - hpp
    operatingExpense: number;
    netProfit: number;      // grossProfit - operatingExpense
    margin: number;         // netProfit / revenue * 100
  };
  piutang: {
    beginning: number;
    newReceivables: number;
    payments: number;
    ending: number;
    aging: {
      current: number;
      overdue1to30: number;
      overdue31to60: number;
      overdue61to90: number;
      overdue90plus: number;
    };
  };
  hutang: {
    beginning: number;
    newPayables: number;
    payments: number;
    ending: number;
  };
}
```

Product Performance:
- GET /api/reports/products?period=monthly&top=10
Response:
```typescript
interface ProductPerformanceResponse {
  period: string;
  topSelling: {
    rank: number;
    productId: string;
    productName: string;
    quantitySold: number;
    revenue: number;
    margin: number;
  }[];
  slowMoving: {
    productId: string;
    productName: string;
    stockAge: number;       // days
    currentStock: number;
  }[];
}
```

Warung Performance:
- GET /api/reports/warungs?period=monthly
Response:
```typescript
interface WarungPerformanceResponse {
  period: string;
  warungs: {
    warungId: string;
    warungName: string;
    totalOrders: number;
    totalPurchase: number;
    totalPayment: number;
    currentDebt: number;
    paymentScore: number;   // 0-100 (based on on-time payment)
    status: 'ACTIVE' | 'BLOCKED';
  }[];
}
```

IMPLEMENTATION:

Dashboard Service:
```typescript
@Injectable()
export class ReportsService {
  constructor(private prisma: PrismaService) {}
  
  async getDashboard(userId: string) {
    const today = new Date();
    const startOfDay = new Date(today.setHours(0, 0, 0, 0));
    const endOfDay = new Date(today.setHours(23, 59, 59, 999));
    
    // Omzet hari ini
    const todaySales = await this.prisma.sale.aggregate({
      where: {
        createdAt: {
          gte: startOfDay,
          lte: endOfDay
        }
      },
      _sum: { totalAmount: true },
      _count: true
    });
    
    // Piutang belum lunas
    const unpaidReceivables = await this.prisma.receivable.aggregate({
      where: {
        status: { in: ['UNPAID', 'PARTIAL', 'OVERDUE'] }
      },
      _sum: { balance: true }
    });
    
    // Laba hari ini (simplified: sales - hpp)
    // TODO: calculate actual HPP from sale items
    
    // Kas/Bank
    // TODO: get from cash flow table
    
    // Chart omzet bulanan (12 bulan terakhir)
    const chartData = await this.getMonthlyChart();
    
    // Warung stats
    const warungStats = await this.prisma.warung.groupBy({
      by: ['isBlocked'],
      _count: true
    });
    
    // Low stock count
    const lowStockCount = await this.prisma.stock.count({
      where: {
        quantity: { lt: this.prisma.stock.fields.minStock }
      }
    });
    
    // Stock valuation
    // TODO: calculate from stocks √ó buyPrice
    
    // Top products (last 30 days)
    const topProducts = await this.getTopProducts(30);
    
    return {
      today: {
        omzet: todaySales._sum.totalAmount || 0,
        piutangBelumLunas: unpaidReceivables._sum.balance || 0,
        labaHariIni: 0, // TODO
        kasBank: 0, // TODO
      },
      chart: chartData,
      warung: {
        totalAktif: warungStats.find(s => !s.isBlocked)?._count || 0,
        totalBlocked: warungStats.find(s => s.isBlocked)?._count || 0,
      },
      stocks: {
        lowStockCount,
        totalValue: 0, // TODO
      },
      topProducts
    };
  }
  
  private async getMonthlyChart() {
    // Get last 12 months data
    // Group sales by month
    // TODO: implement
  }
  
  private async getTopProducts(days: number) {
    const since = new Date();
    since.setDate(since.getDate() - days);
    
    const result = await this.prisma.saleItem.groupBy({
      by: ['productId'],
      where: {
        sale: {
          createdAt: { gte: since }
        }
      },
      _sum: {
        quantity: true,
        subtotal: true
      },
      orderBy: {
        _sum: {
          subtotal: 'desc'
        }
      },
      take: 5
    });
    
    // Join with product details
    // TODO: implement
    
    return result;
  }
  
  async getDailyReport(date: string) {
    // TODO: implement
  }
  
  async getMonthlyReport(month: string) {
    // TODO: implement
  }
}
```

AUTHORIZATION:
- Admin: full access to all reports
- Gudang: access to stock & product reports
- Warung: only own performance report
- Kurir: basic dashboard only

CACHING:
Untuk report yang berat, gunakan Redis caching:
```typescript
@Injectable()
export class ReportsService {
  constructor(
    private prisma: PrismaService,
    @Inject(CACHE_MANAGER) private cache: Cache
  ) {}
  
  async getDashboard(userId: string) {
    const cacheKey = `dashboard:${userId}:${new Date().toDateString()}`;
    
    const cached = await this.cache.get(cacheKey);
    if (cached) return cached;
    
    const data = await this.computeDashboard(userId);
    
    await this.cache.set(cacheKey, data, { ttl: 300 }); // 5 min
    
    return data;
  }
}
```

EXPORT FEATURES:
- Export daily/monthly report to Excel
- Export receivables aging to Excel
- Export product performance to PDF

Berikan code lengkap dengan complex queries, aggregations, dan optimizations!

üì± PHASE 2: MOBILE APP DEVELOPMENT
üîπ PROMPT 2.1: Flutter Project Setup & Structure
markdownBuatkan Flutter project structure lengkap untuk aplikasi BUMAS dengan arsitektur clean dan modular.

REQUIREMENTS:
1. Multi-role app (Admin, Gudang, Kurir, Warung)
2. Offline-first capability
3. State management: Riverpod
4. Local database: Hive
5. Network: Dio
6. Routing: go_router
7. UI: Material Design 3

PROJECT STRUCTURE:
```
mobile_app/
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ main.dart
‚îÇ   ‚îú‚îÄ‚îÄ app.dart
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app_config.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api_config.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ theme_config.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ constants/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ colors.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ strings.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ assets.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ date_utils.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ currency_utils.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validation_utils.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dialog_utils.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ errors/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ failures.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ exceptions.dart
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ network/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ dio_client.dart
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ api_interceptor.dart
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ network_info.dart
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user_model.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product_model.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stock_model.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sale_model.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ receivable_model.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ repositories/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth_repository.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product_repository.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stock_repository.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sale_repository.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ datasources/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ remote/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth_remote_datasource.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product_remote_datasource.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ local/
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ hive_service.dart
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ secure_storage_service.dart
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sync/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ sync_service.dart
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ sync_queue.dart
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ entities/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sale.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ usecases/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ login_usecase.dart
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ logout_usecase.dart
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ sales/
‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ create_sale_usecase.dart
‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ presentation/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ providers/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth_provider.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product_provider.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cart_provider.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ screens/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login_screen.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ splash_screen.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ admin/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ admin_dashboard_screen.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ warung_management_screen.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product_management_screen.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ reports_screen.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ warung/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pos_screen.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cart_screen.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stock_screen.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ receivables_screen.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ payment_screen.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ kurir/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ delivery_list_screen.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ delivery_detail_screen.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ delivery_history_screen.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ gudang/
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ stock_overview_screen.dart
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ receive_goods_screen.dart
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ prepare_delivery_screen.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ widgets/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ common/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ custom_button.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ custom_textfield.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ loading_widget.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ error_widget.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ empty_state.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product_card.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cart_item.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ receivable_card.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ router/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ app_router.dart
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ services/
‚îÇ       ‚îú‚îÄ‚îÄ barcode_service.dart
‚îÇ       ‚îú‚îÄ‚îÄ printer_service.dart
‚îÇ       ‚îú‚îÄ‚îÄ notification_service.dart
‚îÇ       ‚îî‚îÄ‚îÄ location_service.dart
‚îÇ
‚îú‚îÄ‚îÄ assets/
‚îÇ   ‚îú‚îÄ‚îÄ images/
‚îÇ   ‚îú‚îÄ‚îÄ icons/
‚îÇ   ‚îî‚îÄ‚îÄ fonts/
‚îÇ
‚îú‚îÄ‚îÄ pubspec.yaml
‚îú‚îÄ‚îÄ analysis_options.yaml
‚îî‚îÄ‚îÄ README.md
```

GENERATE FILES:

1. `pubspec.yaml`:
```yaml
name: bumas_app
description: BUMAS Distribution Management System
version: 1.0.0+1

environment:
  sdk: '>=3.0.0 <4.0.0'

dependencies:
  flutter:
    sdk: flutter
  
  # State Management
  flutter_riverpod: ^2.4.0
  riverpod_annotation: ^2.3.0
  
  # Network
  dio: ^5.4.0
  retrofit: ^4.0.0
  pretty_dio_logger: ^1.3.0
  
  # Local Storage
  hive: ^2.2.3
  hive_flutter: ^1.1.0
  flutter_secure_storage: ^9.0.0
  
  # Routing
  go_router: ^13.0.0
  
  # UI
  flutter_screenutil: ^5.9.0
  google_fonts: ^6.1.0
  cached_network_image: ^3.3.0
  shimmer: ^3.0.0
  lottie: ^2.7.0
  
  # Barcode
  mobile_scanner: ^3.5.0
  qr_flutter: ^4.1.0
  
  # Utilities
  intl: ^0.18.1
  shared_preferences: ^2.2.2
  connectivity_plus: ^5.0.2
  image_picker: ^1.0.5
  permission_handler: ^11.1.0
  
  # Printing
  esc_pos_utils: ^1.1.0
  esc_pos_bluetooth: ^0.4.1

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^3.0.0
  
  # Code Generation
  build_runner: ^2.4.7
  riverpod_generator: ^2.3.0
  hive_generator: ^2.0.1
  json_serializable: ^6.7.1
  retrofit_generator: ^8.0.0

flutter:
  uses-material-design: true
  assets:
    - assets/images/
    - assets/icons/
```

2. `lib/main.dart`:
```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'app.dart';
import 'data/datasources/local/hive_service.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  
  // Initialize Hive
  await Hive.initFlutter();
  await HiveService.init();
  
  runApp(
    const ProviderScope(
      child: MyApp(),
    ),
  );
}
```

3. `lib/app.dart`:
```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'package:google_fonts/google_fonts.dart';
import 'presentation/router/app_router.dart';
import 'core/config/theme_config.dart';

class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final router = ref.watch(routerProvider);
    
    return ScreenUtilInit(
      designSize: const Size(375, 812),
      minTextAdapt: true,
      builder: (context, child) {
        return MaterialApp.router(
          title: 'BUMAS',
          theme: ThemeConfig.lightTheme,
          darkTheme: ThemeConfig.darkTheme,
          themeMode: ThemeMode.light,
          routerConfig: router,
          debugShowCheckedModeBanner: false,
        );
      },
    );
  }
}
```

4. `lib/core/config/theme_config.dart`:
```dart
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

class ThemeConfig {
  static ThemeData get lightTheme {
    return ThemeData(
      useMaterial3: true,
      colorScheme: ColorScheme.fromSeed(
        seedColor: const Color(0xFF2E7D32), // BUMAS green
        brightness: Brightness.light,
      ),
      textTheme: GoogleFonts.interTextTheme(),
      appBarTheme: const AppBarTheme(
        centerTitle: true,
        elevation: 0,
      ),
      cardTheme: CardTheme(
        elevation: 2,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
        ),
        filled: true,
      ),
    );
  }
  
  static ThemeData get darkTheme {
    return ThemeData(
      useMaterial3: true,
      colorScheme: ColorScheme.fromSeed(
        seedColor: const Color(0xFF2E7D32),
        brightness: Brightness.dark,
      ),
      textTheme: GoogleFonts.interTextTheme(ThemeData.dark().textTheme),
    );
  }
}
```

5. `lib/core/network/dio_client.dart`:
```dart
import 'package:dio/dio.dart';
import 'package:pretty_dio_logger/pretty_dio_logger.dart';
import '../config/api_config.dart';
import 'api_interceptor.dart';

class DioClient {
  static Dio? _dio;
  
  static Dio get instance {
    if (_dio != null) return _dio!;
    
    _dio = Dio(
      BaseOptions(
        baseUrl: ApiConfig.baseUrl,
        connectTimeout: const Duration(seconds: 30),
        receiveTimeout: const Duration(seconds: 30),
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
      ),
    );
    
    _dio!.interceptors.addAll([
      ApiInterceptor(),
      PrettyDioLogger(
        requestHeader: true,
        requestBody: true,
        responseHeader: true,
      ),
    ]);
    
    return _dio!;
  }
}
```

6. `lib/data/datasources/local/hive_service.dart`:
```dart
import 'package:hive_flutter/hive_flutter.dart';

class HiveService {
  static const String _authBox = 'auth_box';
  static const String _syncQueueBox = 'sync_queue_box';
  static const String _cacheBox = 'cache_box';
  
  static Future init() async {
    // Register adapters
    // Hive.registerAdapter(UserAdapter());
    // Hive.registerAdapter(ProductAdapter());
    
    // Open boxes
    await Hive.openBox(_authBox);
    await Hive.openBox(_syncQueueBox);
    await Hive.openBox(_cacheBox);
  }
  
  static Box get authBox => Hive.box(_authBox);
  static Box get syncQueueBox => Hive.box(_syncQueueBox);
  static Box get cacheBox => Hive.box(_cacheBox);
}
```

Berikan semua file yang disebutkan dengan implementasi lengkap!