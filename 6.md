PROMPT 3.3: Flutter Widget & Integration Testing
markdownBuatkan comprehensive testing untuk Flutter app BUMAS.

REQUIREMENTS:
1. Widget tests untuk UI components
2. Integration tests untuk user flows
3. Mock providers dengan Riverpod
4. Golden tests untuk UI consistency
5. Test coverage minimal 70%

GENERATE FILES:

1. `mobile_app/test/widget_test/login_screen_test.dart`:
```dart
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:mockito/mockito.dart';
import 'package:mockito/annotations.dart';
import 'package:bumas_app/presentation/screens/auth/login_screen.dart';
import 'package:bumas_app/presentation/providers/auth_provider.dart';
import 'package:bumas_app/data/repositories/auth_repository.dart';

@GenerateMocks([AuthRepository])
import 'login_screen_test.mocks.dart';

void main() {
  late MockAuthRepository mockAuthRepository;

  setUp(() {
    mockAuthRepository = MockAuthRepository();
  });

  Widget createWidgetUnderTest() {
    return ProviderScope(
      overrides: [
        authRepositoryProvider.overrideWithValue(mockAuthRepository),
      ],
      child: const MaterialApp(
        home: LoginScreen(),
      ),
    );
  }

  group('LoginScreen Widget Tests', () {
    testWidgets('should display all UI elements', (tester) async {
      await tester.pumpWidget(createWidgetUnderTest());

      // Check for logo
      expect(find.text('BUMAS'), findsOneWidget);
      expect(find.text('BUM Ansor Banyumas'), findsOneWidget);

      // Check for text fields
      expect(find.byType(TextField), findsNWidgets(2));
      expect(find.text('Email'), findsOneWidget);
      expect(find.text('Password'), findsOneWidget);

      // Check for login button
      expect(find.text('Login'), findsOneWidget);
    });

    testWidgets('should show error when email is empty', (tester) async {
      await tester.pumpWidget(createWidgetUnderTest());

      // Tap login without entering email
      await tester.tap(find.text('Login'));
      await tester.pump();

      expect(find.text('Email tidak boleh kosong'), findsOneWidget);
    });

    testWidgets('should show error when email is invalid', (tester) async {
      await tester.pumpWidget(createWidgetUnderTest());

      // Enter invalid email
      await tester.enterText(
        find.widgetWithText(TextField, 'Email'),
        'invalid-email',
      );

      await tester.tap(find.text('Login'));
      await tester.pump();

      expect(find.text('Email tidak valid'), findsOneWidget);
    });

    testWidgets('should show error when password is too short', (tester) async {
      await tester.pumpWidget(createWidgetUnderTest());

      await tester.enterText(
        find.widgetWithText(TextField, 'Email'),
        'test@example.com',
      );

      await tester.enterText(
        find.widgetWithText(TextField, 'Password'),
        '12345',
      );

      await tester.tap(find.text('Login'));
      await tester.pump();

      expect(find.text('Password minimal 6 karakter'), findsOneWidget);
    });

    testWidgets('should toggle password visibility', (tester) async {
      await tester.pumpWidget(createWidgetUnderTest());

      // Password should be obscured initially
      final passwordField = tester.widget(
        find.widgetWithText(TextField, 'Password'),
      );
      expect(passwordField.obscureText, true);

      // Tap visibility toggle
      await tester.tap(find.byIcon(Icons.visibility_outlined));
      await tester.pump();

      // Password should be visible now
      final passwordFieldAfter = tester.widget(
        find.widgetWithText(TextField, 'Password'),
      );
      expect(passwordFieldAfter.obscureText, false);
    });

    testWidgets('should call login with valid credentials', (tester) async {
      when(mockAuthRepository.login(any, any)).thenAnswer(
        (_) async => AuthResponse(
          accessToken: 'token',
          refreshToken: 'refresh',
          user: UserModel(
            id: '1',
            email: 'test@example.com',
            name: 'Test User',
            role: UserRole.warung,
          ),
        ),
      );

      await tester.pumpWidget(createWidgetUnderTest());

      await tester.enterText(
        find.widgetWithText(TextField, 'Email'),
        'test@example.com',
      );

      await tester.enterText(
        find.widgetWithText(TextField, 'Password'),
        'password123',
      );

      await tester.tap(find.text('Login'));
      await tester.pump();

      verify(mockAuthRepository.login('test@example.com', 'password123'))
          .called(1);
    });

    testWidgets('should show loading indicator during login', (tester) async {
      when(mockAuthRepository.login(any, any)).thenAnswer(
        (_) async {
          await Future.delayed(const Duration(seconds: 1));
          return AuthResponse(
            accessToken: 'token',
            refreshToken: 'refresh',
            user: UserModel(
              id: '1',
              email: 'test@example.com',
              name: 'Test User',
              role: UserRole.warung,
            ),
          );
        },
      );

      await tester.pumpWidget(createWidgetUnderTest());

      await tester.enterText(
        find.widgetWithText(TextField, 'Email'),
        'test@example.com',
      );

      await tester.enterText(
        find.widgetWithText(TextField, 'Password'),
        'password123',
      );

      await tester.tap(find.text('Login'));
      await tester.pump();

      // Should show loading indicator
      expect(find.byType(CircularProgressIndicator), findsOneWidget);
    });

    testWidgets('should show error snackbar on login failure', (tester) async {
      when(mockAuthRepository.login(any, any)).thenThrow(
        Exception('Invalid credentials'),
      );

      await tester.pumpWidget(createWidgetUnderTest());

      await tester.enterText(
        find.widgetWithText(TextField, 'Email'),
        'test@example.com',
      );

      await tester.enterText(
        find.widgetWithText(TextField, 'Password'),
        'wrongpassword',
      );

      await tester.tap(find.text('Login'));
      await tester.pump();
      await tester.pump(const Duration(seconds: 1));

      expect(find.byType(SnackBar), findsOneWidget);
      expect(find.text('Exception: Invalid credentials'), findsOneWidget);
    });
  });
}
```

2. `mobile_app/test/widget_test/product_card_test.dart`:
```dart
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:bumas_app/presentation/widgets/product_card.dart';
import 'package:bumas_app/data/models/product_model.dart';

void main() {
  group('ProductCard Widget Tests', () {
    final testProduct = ProductModel(
      id: '1',
      name: 'Indomie Goreng',
      barcode: 'INDO001',
      categoryId: 'cat-1',
      buyPrice: 2500,
      sellPrice: 3000,
      margin: 20,
      unit: 'pcs',
      currentStock: 100,
    );

    testWidgets('should display product information correctly', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ProductCard(
              product: testProduct,
              onTap: () {},
            ),
          ),
        ),
      );

      expect(find.text('Indomie Goreng'), findsOneWidget);
      expect(find.text('Rp 3000'), findsOneWidget);
      expect(find.text('Stok: 100 pcs'), findsOneWidget);
    });

    testWidgets('should show low stock indicator when stock is low', (tester) async {
      final lowStockProduct = testProduct.copyWith(currentStock: 5);

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ProductCard(
              product: lowStockProduct,
              onTap: () {},
            ),
          ),
        ),
      );

      expect(find.text('Stok: 5 pcs'), findsOneWidget);
      // Low stock indicator should be visible
      // Add your specific low stock UI element check here
    });

    testWidgets('should call onTap when tapped', (tester) async {
      bool wasTapped = false;

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ProductCard(
              product: testProduct,
              onTap: () {
                wasTapped = true;
              },
            ),
          ),
        ),
      );

      await tester.tap(find.byType(ProductCard));
      await tester.pump();

      expect(wasTapped, true);
    });

    testWidgets('should display in list view mode', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: ProductCard(
              product: testProduct,
              onTap: () {},
              isListView: true,
            ),
          ),
        ),
      );

      expect(find.byType(ListTile), findsOneWidget);
    });
  });
}
```

3. `mobile_app/test/integration_test/pos_flow_test.dart`:
```dart
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:bumas_app/main.dart' as app;

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('Complete POS Flow Integration Test', () {
    testWidgets('Complete sale transaction flow', (tester) async {
      // Start app
      app.main();
      await tester.pumpAndSettle();

      // Step 1: Login
      await tester.enterText(
        find.byKey(const Key('email_field')),
        'warung@test.com',
      );
      await tester.enterText(
        find.byKey(const Key('password_field')),
        'password123',
      );
      await tester.tap(find.text('Login'));
      await tester.pumpAndSettle();

      // Should navigate to POS screen
      expect(find.text('POS - Point of Sale'), findsOneWidget);

      // Step 2: Search and add product to cart
      await tester.enterText(
        find.byType(TextField),
        'Indomie',
      );
      await tester.pumpAndSettle();

      // Tap first product
      await tester.tap(find.byType(ProductCard).first);
      await tester.pumpAndSettle();

      // Should see cart badge
      expect(find.byType(Badge), findsOneWidget);

      // Step 3: Add more quantity
      await tester.tap(find.byType(ProductCard).first);
      await tester.pumpAndSettle();

      // Step 4: Go to checkout
      await tester.tap(find.byType(FloatingActionButton));
      await tester.pumpAndSettle();

      // Should navigate to checkout screen
      expect(find.text('Checkout'), findsOneWidget);

      // Step 5: Select payment method
      await tester.tap(find.text('Cash'));
      await tester.pumpAndSettle();

      // Step 6: Enter cash received
      await tester.enterText(
        find.byKey(const Key('cash_received_field')),
        '50000',
      );
      await tester.pumpAndSettle();

      // Should show change
      expect(find.textContaining('Kembalian'), findsOneWidget);

      // Step 7: Process payment
      await tester.tap(find.text('Proses Pembayaran'));
      await tester.pumpAndSettle(const Duration(seconds: 2));

      // Should navigate to receipt screen
      expect(find.text('Transaksi Berhasil'), findsOneWidget);
      expect(find.textContaining('SALE-'), findsOneWidget);

      // Step 8: Share/print receipt
      expect(find.byIcon(Icons.share), findsOneWidget);
      expect(find.byIcon(Icons.print), findsOneWidget);
    });

    testWidgets('Offline mode transaction', (tester) async {
      app.main();
      await tester.pumpAndSettle();

      // Login
      await tester.enterText(
        find.byKey(const Key('email_field')),
        'warung@test.com',
      );
      await tester.enterText(
        find.byKey(const Key('password_field')),
        'password123',
      );
      await tester.tap(find.text('Login'));
      await tester.pumpAndSettle();

      // Simulate offline mode
      // (You'll need to implement a way to toggle offline mode for testing)

      // Add product to cart
      await tester.tap(find.byType(ProductCard).first);
      await tester.pumpAndSettle();

      // Go to checkout
      await tester.tap(find.byType(FloatingActionButton));
      await tester.pumpAndSettle();

      // Process payment
      await tester.tap(find.text('Cash'));
      await tester.enterText(
        find.byKey(const Key('cash_received_field')),
        '50000',
      );
      await tester.tap(find.text('Proses Pembayaran'));
      await tester.pumpAndSettle();

      // Should show offline indicator
      expect(find.textContaining('offline'), findsOneWidget);
      expect(find.textContaining('disinkronkan'), findsOneWidget);

      // Should see pending sync count
      expect(find.byIcon(Icons.cloud_off), findsOneWidget);
    });

    testWidgets('Barcode scanning flow', (tester) async {
      app.main();
      await tester.pumpAndSettle();

      // Login
      await tester.enterText(
        find.byKey(const Key('email_field')),
        'warung@test.com',
      );
      await tester.enterText(
        find.byKey(const Key('password_field')),
        'password123',
      );
      await tester.tap(find.text('Login'));
      await tester.pumpAndSettle();

      // Open barcode scanner
      await tester.tap(find.byIcon(Icons.qr_code_scanner));
      await tester.pumpAndSettle();

      // Should show scanner screen
      expect(find.text('Scan Barcode'), findsOneWidget);

      // Simulate barcode scan
      // (You'll need to mock the scanner for testing)

      // Should add product to cart
      expect(find.byType(SnackBar), findsOneWidget);
      expect(find.textContaining('ditambahkan'), findsOneWidget);
    });
  });
}
```

4. `mobile_app/test/provider_test/cart_provider_test.dart`:
```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:bumas_app/presentation/providers/cart_provider.dart';
import 'package:bumas_app/data/models/product_model.dart';

void main() {
  group('CartProvider Tests', () {
    late ProviderContainer container;

    setUp(() {
      container = ProviderContainer();
    });

    tearDown(() {
      container.dispose();
    });

    final testProduct1 = ProductModel(
      id: '1',
      name: 'Product 1',
      barcode: 'PROD001',
      categoryId: 'cat-1',
      buyPrice: 5000,
      sellPrice: 7000,
      margin: 40,
      unit: 'pcs',
    );

    final testProduct2 = ProductModel(
      id: '2',
      name: 'Product 2',
      barcode: 'PROD002',
      categoryId: 'cat-1',
      buyPrice: 10000,
      sellPrice: 12000,
      margin: 20,
      unit: 'pcs',
    );

    test('should start with empty cart', () {
      final cart = container.read(cartProvider);
      expect(cart, isEmpty);
    });

    test('should add product to cart', () {
      final notifier = container.read(cartProvider.notifier);
      
      notifier.addProduct(testProduct1);
      
      final cart = container.read(cartProvider);
      expect(cart.length, 1);
      expect(cart[0].product.id, '1');
      expect(cart[0].quantity, 1);
    });

    test('should increase quantity if product already in cart', () {
      final notifier = container.read(cartProvider.notifier);
      
      notifier.addProduct(testProduct1);
      notifier.addProduct(testProduct1);
      
      final cart = container.read(cartProvider);
      expect(cart.length, 1);
      expect(cart[0].quantity, 2);
    });

    test('should add multiple different products', () {
      final notifier = container.read(cartProvider.notifier);
      
      notifier.addProduct(testProduct1);
      notifier.addProduct(testProduct2);
      
      final cart = container.read(cartProvider);
      expect(cart.length, 2);
    });

    test('should update quantity correctly', () {
      final notifier = container.read(cartProvider.notifier);
      
      notifier.addProduct(testProduct1);
      notifier.updateQuantity('1', 5);
      
      final cart = container.read(cartProvider);
      expect(cart[0].quantity, 5);
    });

    test('should remove product when quantity set to 0', () {
      final notifier = container.read(cartProvider.notifier);
      
      notifier.addProduct(testProduct1);
      notifier.updateQuantity('1', 0);
      
      final cart = container.read(cartProvider);
      expect(cart, isEmpty);
    });

    test('should calculate subtotal correctly', () {
      final notifier = container.read(cartProvider.notifier);
      
      notifier.addProduct(testProduct1, quantity: 2); // 2 * 7000 = 14000
      notifier.addProduct(testProduct2, quantity: 3); // 3 * 12000 = 36000
      
      final subtotal = container.read(cartSubtotalProvider);
      expect(subtotal, 50000);
    });

    test('should calculate total items correctly', () {
      final notifier = container.read(cartProvider.notifier);
      
      notifier.addProduct(testProduct1, quantity: 2);
      notifier.addProduct(testProduct2, quantity: 3);
      
      final totalItems = container.read(cartTotalItemsProvider);
      expect(totalItems, 5);
    });

    test('should apply discount correctly', () {
      final notifier = container.read(cartProvider.notifier);
      
      notifier.addProduct(testProduct1);
      notifier.updateDiscount('1', 1000);
      
      final cart = container.read(cartProvider);
      expect(cart[0].discount, 1000);
      expect(cart[0].subtotal, 6000); // 7000 - 1000
    });

    test('should clear cart', () {
      final notifier = container.read(cartProvider.notifier);
      
      notifier.addProduct(testProduct1);
      notifier.addProduct(testProduct2);
      notifier.clear();
      
      final cart = container.read(cartProvider);
      expect(cart, isEmpty);
    });
  });
}
```

5. `mobile_app/test_driver/app.dart`:
```dart
import 'package:flutter_driver/driver_extension.dart';
import 'package:bumas_app/main.dart' as app;

void main() {
  enableFlutterDriverExtension();
  app.main();
}
```

6. `mobile_app/test_driver/app_test.dart`:
```dart
import 'package:flutter_driver/flutter_driver.dart';
import 'package:test/test.dart';

void main() {
  group('BUMAS App Driver Tests', () {
    late FlutterDriver driver;

    setUpAll(() async {
      driver = await FlutterDriver.connect();
    });

    tearDownAll(() async {
      await driver.close();
    });

    test('complete login to sale flow', () async {
      // Login
      await driver.tap(find.byValueKey('email_field'));
      await driver.enterText('warung@test.com');
      
      await driver.tap(find.byValueKey('password_field'));
      await driver.enterText('password123');
      
      await driver.tap(find.text('Login'));
      await driver.waitFor(find.text('POS - Point of Sale'));

      // Add product
      await driver.tap(find.byType('ProductCard'));
      await driver.waitFor(find.byType('Badge'));

      // Checkout
      await driver.tap(find.byType('FloatingActionButton'));
      await driver.waitFor(find.text('Checkout'));

      // Complete payment
      await driver.tap(find.text('Cash'));
      await driver.tap(find.byValueKey('cash_received_field'));
      await driver.enterText('50000');
      
      await driver.tap(find.text('Proses Pembayaran'));
      await driver.waitFor(find.text('Transaksi Berhasil'));
    });

    test('performance test - scroll product list', () async {
      final timeline = await driver.traceAction(() async {
        for (int i = 0; i < 10; i++) {
          await driver.scroll(
            find.byType('ListView'),
            0,
            -300,
            const Duration(milliseconds: 300),
          );
          await Future.delayed(const Duration(milliseconds: 500));
        }
      });

      final summary = TimelineSummary.summarize(timeline);
      
      // Check frame build time
      expect(summary.summaryJson['average_frame_build_time_millis'], lessThan(16));
      
      // Save summary
      await summary.writeSummaryToFile('scroll_summary', pretty: true);
      await summary.writeTimelineToFile('scroll_timeline', pretty: true);
    });
  });
}
```

7. `mobile_app/pubspec.yaml` - add test dependencies:
```yaml
dev_dependencies:
  flutter_test:
    sdk: flutter
  integration_test:
    sdk: flutter
  mockito: ^5.4.4
  build_runner: ^2.4.7
  flutter_driver:
    sdk: flutter
  test: ^1.24.9
```

8. Create `mobile_app/test/helpers/test_helpers.dart`:
```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Helper to create widget for testing with providers
Widget createTestWidget(
  Widget child, {
  List overrides = const [],
}) {
  return ProviderScope(
    overrides: overrides,
    child: MaterialApp(
      home: child,
    ),
  );
}

/// Helper to pump widget and settle
Future pumpWidgetAndSettle(
  WidgetTester tester,
  Widget widget,
) async {
  await tester.pumpWidget(widget);
  await tester.pumpAndSettle();
}
```

RUN TESTS:
```bash
# Unit & Widget tests
flutter test

# Integration tests
flutter test integration_test/

# Driver tests
flutter drive --target=test_driver/app.dart

# Coverage report
flutter test --coverage
genhtml coverage/lcov.info -o coverage/html
open coverage/html/index.html
```

Berikan implementasi lengkap dengan semua test scenarios!

ðŸš¢ PHASE 4: DEPLOYMENT & PRODUCTION
ðŸ”¹ PROMPT 4.1: Backend Deployment (Docker + Cloud)
markdownBuatkan deployment setup lengkap untuk backend NestJS BUMAS.

REQUIREMENTS:
1. Docker containerization
2. Docker Compose untuk development
3. Production deployment (Railway/Render/AWS)
4. Environment configuration
5. Database migration strategy
6. CI/CD pipeline
7. Monitoring & logging

GENERATE FILES:

1. `backend/Dockerfile`:
```dockerfile
# Multi-stage build for production

# Stage 1: Build
FROM node:20-alpine AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./
COPY prisma ./prisma/

# Install dependencies
RUN npm ci

# Copy source code
COPY . .

# Generate Prisma Client
RUN npx prisma generate

# Build application
RUN npm run build

# Stage 2: Production
FROM node:20-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install only production dependencies
RUN npm ci --only=production

# Copy built application from builder
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules/.prisma ./node_modules/.prisma
COPY --from=builder /app/prisma ./prisma

# Expose port
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s \
  CMD node -e "require('http').get('http://localhost:3000/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})"

# Start application
CMD ["node", "dist/main.js"]
```

2. `backend/docker-compose.yml`:
```yaml
version: '3.8'

services:
  # PostgreSQL Database
  postgres:
    image: postgres:15-alpine
    container_name: bumas-postgres
    restart: unless-stopped
    environment:
      POSTGRES_USER: ${DB_USER:-bumas}
      POSTGRES_PASSWORD: ${DB_PASSWORD:-bumas123}
      POSTGRES_DB: ${DB_NAME:-bumas_db}
    ports:
      - '5432:5432'
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-scripts:/docker-entrypoint-initdb.d
    networks:
      - bumas-network
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U bumas']
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis Cache
  redis:
    image: redis:7-alpine
    container_name: bumas-redis
    restart: unless-stopped
    ports:
      - '6379:6379'
    volumes:
      - redis_data:/data
    networks:
      - bumas-network
    healthcheck:
      test: ['CMD', 'redis-cli', 'ping']
      interval: 10s
      timeout: 3s
      retries: 5

  # NestJS Application
  app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: bumas-app
    restart: unless-stopped
    ports:
      - '3000:3000'
    environment:
      NODE_ENV: ${NODE_ENV:-production}
      DATABASE_URL: postgresql://${DB_USER:-bumas}:${DB_PASSWORD:-bumas123}@postgres:5432/${DB_NAME:-bumas_db}?schema=public
      REDIS_HOST: redis
      REDIS_PORT: 6379
      JWT_SECRET: ${JWT_SECRET}
      JWT_REFRESH_SECRET: ${JWT_REFRESH_SECRET}
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - bumas-network
    volumes:
      - ./uploads:/app/uploads
    command: sh -c "npx prisma migrate deploy && node dist/main.js"

  # Nginx Reverse Proxy
  nginx:
    image: nginx:alpine
    container_name: bumas-nginx
    restart: unless-stopped
    ports:
      - '80:80'
      - '443:443'
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
    depends_on:
      - app
    networks:
      - bumas-network

volumes:
  postgres_data:
  redis_data:

networks:
  bumas-network:
    driver: bridge
```

3. `backend/nginx/nginx.conf`:
```nginx
events {
    worker_connections 1024;
}

http {
    upstream backend {
        server app:3000;
    }

    # Rate limiting
    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;

    server {
        listen 80;
        server_name api.bumas.id;

        # Redirect to HTTPS
        return 301 https://$server_name$request_uri;
    }

    server {
        listen 443 ssl http2;
        server_name api.bumas.id;

        # SSL Configuration
        ssl_certificate /etc/nginx/ssl/fullchain.pem;
        ssl_certificate_key /etc/nginx/ssl/privkey.pem;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers HIGH:!aNULL:!MD5;

        # Security headers
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

        # Client body size
        client_max_body_size 10M;

        # Proxy settings
        location / {
            limit_req zone=api_limit burst=20 nodelay;
            
            proxy_pass http://backend;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_cache_bypass $http_upgrade;
        }

        # Health check endpoint
        location /health {
            proxy_pass http://backend/health;
            access_log off;
        }

        # Static files
        location /uploads {
            alias /app/uploads;
            expires 30d;
            add_header Cache-Control "public, immutable";
        }
    }
}
```

4. `backend/.env.production.example`:
```env
# Application
NODE_ENV=production
PORT=3000
APP_URL=https://api.bumas.id

# Database
DATABASE_URL=postgresql://user:password@host:5432/database?schema=public

# Redis
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=

# JWT
JWT_SECRET=your-super-secret-jwt-key-change-this-in-production
JWT_REFRESH_SECRET=your-super-secret-refresh-key-change-this-in-production
JWT_EXPIRY=15m
JWT_REFRESH_EXPIRY=7d

# Email (Optional)
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your-email@gmail.com
SMTP_PASSWORD=your-app-password

# File Upload
MAX_FILE_SIZE=10485760
UPLOAD_DIR=./uploads

# Monitoring
SENTRY_DSN=

# CORS
CORS_ORIGIN=https://bumas.id,https://app.bumas.id
```

5. `.github/workflows/deploy.yml`:
```yaml
name: Deploy to Production

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: test_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Generate Prisma Client
        run: npx prisma generate
      
      - name: Run migrations
        run: npx prisma migrate deploy
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/test_db
      
      - name: Run tests
        run: npm test
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/test_db
      
      - name: Run E2E tests
        run: npm run test:e2e
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/test_db

  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      
      - name: Build and push
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/bumas-backend:latest
            ${{ secrets.DOCKER_USERNAME }}/bumas-backend:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Deploy to Railway
        run: |
          npm install -g @railway/cli
          railway up
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
      
      - name: Run migrations
        run: railway run npx prisma migrate deploy
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
      
      - name: Notify deployment
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: 'Deployment to production completed!'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        if: always()
```

6. `backend/scripts/deploy.sh`:
```bash
#!/bin/bash

set -e

echo "ðŸš€ Starting deployment..."

# Load environment variables
if [ -f .env.production ]; then
  export $(cat .env.production | xargs)
fi

# Build Docker image
echo "ðŸ“¦ Building Docker image..."
docker build -t bumas-backend:latest .

# Stop existing containers
echo "ðŸ›‘ Stopping existing containers..."
docker-compose -f docker-compose.prod.yml down

# Run database migrations
echo "ðŸ“Š Running database migrations..."
docker run --rm \
  -e DATABASE_URL="$DATABASE_URL" \
  bumas-backend:latest \
  npx prisma migrate deploy

# Start containers
echo "â–¶ï¸  Starting containers..."
docker-compose -f docker-compose.prod.yml up -d

# Wait for health check
echo "ðŸ¥ Waiting for health check..."
sleep 10

# Check if app is healthy
if curl -f http://localhost:3000/health > /dev/null 2>&1; then
  echo "âœ… Deployment successful!"
else
  echo "âŒ Health check failed!"
  docker-compose -f docker-compose.prod.yml logs app
  exit 1
fi

# Clean up old images
echo "ðŸ§¹ Cleaning up..."
docker image prune -f

echo "ðŸŽ‰ Deployment completed successfully!"
```

7. `backend/docker-compose.prod.yml`:
```yaml
version: '3.8'

services:
  app:
    image: bumas-backend:latest
    restart: always
    ports:
      - '3000:3000'
    env_file:
      - .env.production
    depends_on:
      - postgres
      - redis
    networks:
      - bumas-network
    volumes:
      - ./uploads:/app/uploads
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M

  postgres:
    image: postgres:15-alpine
    restart: always
    env_file:
      - .env.production
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - bumas-network
    deploy:
      resources:
        limits:
          memory: 512M

  redis:
    image: redis:7-alpine
    restart: always
    volumes:
      - redis_data:/data
    networks:
      - bumas-network

  nginx:
    image: nginx:alpine
    restart: always
    ports:
      - '80:80'
      - '443:443'
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
      - ./uploads:/app/uploads:ro
    depends_on:
      - app
    networks:
      - bumas-network

volumes:
  postgres_data:
  redis_data:

networks:
  bumas-network:
    driver: bridge
```

8. `backend/scripts/backup-db.sh`:
```bash
#!/bin/bash

# Database backup script

BACKUP_DIR="/backups"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="$BACKUP_DIR/bumas_backup_$TIMESTAMP.sql"

# Create backup directory if not exists
mkdir -p $BACKUP_DIR

# Backup database
docker exec bumas-postgres pg_dump -U bumas bumas_db > $BACKUP_FILE

# Compress backup
gzip $BACKUP_FILE

# Keep only last 7 days of backups
find $BACKUP_DIR -name "*.sql.gz" -mtime +7 -delete

echo "Backup completed: $BACKUP_FILE.gz"

# Upload to S3 (optional)
# aws s3 cp $BACKUP_FILE.gz s3://bumas-backups/
```

9. Add cron job for automated backups:
```bash
# Edit crontab
crontab -e

# Add this line (backup every day at 2 AM)
0 2 * * * /path/to/backend/scripts/backup-db.sh >> /var/log/bumas-backup.log 2>&1
```

10. `backend/src/health/health.controller.ts`:
```typescript
import { Controller, Get } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';

@Controller('health')
export class HealthController {
  constructor(private prisma: PrismaService) {}

  @Get()
  async check() {
    try {
      // Check database connection
      await this.prisma.$queryRaw`SELECT 1`;
      
      return {
        status: 'ok',
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        database: 'connected',
      };
    } catch (error) {
      return {
        status: 'error',
        timestamp: new Date().toISOString(),
        database: 'disconnected',
        error: error.message,
      };
    }
  }
}
```

DEPLOYMENT STEPS:
```bash
# 1. Build and test locally
docker-compose up --build

# 2. Run tests
npm test
npm run test:e2e

# 3. Deploy to production
chmod +x scripts/deploy.sh
./scripts/deploy.sh

# 4. Check logs
docker-compose -f docker-compose.prod.yml logs -f app

# 5. Monitor
curl https://api.bumas.id/health
```

MONITORING SETUP:

Install monitoring tools:
```yaml
# Add to docker-compose.prod.yml

  prometheus:
    image: prom/prometheus
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    ports:
      - '9090:9090'

  grafana:
    image: grafana/grafana
    ports:
      - '3001:3000'
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
```

Berikan implementasi lengkap dengan rollback strategy dan monitoring!